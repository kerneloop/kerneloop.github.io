<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Welcome to Kerneloop Blog!</title><link>https://kerneloop.github.io/posts/</link><description>Recent content in Posts on Welcome to Kerneloop Blog!</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Mon, 22 Dec 2025 13:28:55 +0100</lastBuildDate><atom:link href="https://kerneloop.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Autopsy</title><link>https://kerneloop.github.io/posts/autopsy/</link><pubDate>Mon, 22 Dec 2025 13:28:55 +0100</pubDate><guid>https://kerneloop.github.io/posts/autopsy/</guid><description>Forensic Analisys Como analistas forenses se nos presenta una imagen obtenida del equipo personal de un crimen digital. Nuestra tarea es analizar esta imagen de su equipo y sacar las conclusiones que se convertirán en Evidencias Digitales para su posterior presentación.
REQUISITOS Sistema Operativo -&amp;gt; Windows 10
Software -&amp;gt; FTK Imager - Autopsy
PROCEDIMIENTO FTK Imager Para comenzar con este analisis lo primero es hacer una imagen del equipo, para ello utilizaremos FTK Imager.</description><content type="html"><![CDATA[<h1 id="forensic-analisys">Forensic Analisys</h1>
<p><img alt="esquema" src="/images/Autopsy/perro.png">
Como analistas forenses se nos presenta una imagen obtenida del equipo personal de un crimen digital. Nuestra tarea es analizar esta imagen de su equipo y sacar las conclusiones que se convertirán en Evidencias Digitales para su posterior presentación.</p>
<h2 id="requisitos">REQUISITOS</h2>
<p>Sistema Operativo -&gt; Windows 10<br>
Software -&gt; FTK Imager - Autopsy</p>
<h1 id="procedimiento">PROCEDIMIENTO</h1>
<h2 id="ftk-imager">FTK Imager</h2>
<p>Para comenzar con este analisis lo primero es hacer una <strong>imagen del equipo</strong>, para ello utilizaremos FTK Imager. Lo iniciaremos y haremos click en Create Disk Image desde el menu. Nota: El disco duro ha de estar insertado.<br>
<img alt="esquema" src="/images/Autopsy/FTK/1.png"><br>
Se presentará una nueva ventana con las multiples opciones de copiado Elegiremos la <strong>Fisica</strong>.<br>
<img alt="esquema" src="/images/Autopsy/FTK/2.png"><br>
Seleccionaremos el disco duro que vamos a copiar y haremos click en “<em>Siguiente</em>”.<br>
<img alt="esquema" src="/images/Autopsy/FTK/3.png"><br>
En la creacion de imagen le daremos a <strong>Add</strong> para añadir un destino de la imagen.<br>
<img alt="esquema" src="/images/Autopsy/FTK/4.png"><br>
Seleccionaremos el tipo de copiado, en nuestro caso <strong>DD</strong> (Data duplicator) ya que va recorriendo a un <strong>nivel más bajo</strong> los sectores del disco y por ende la copia es de mayor calidad.<br>
<img alt="esquema" src="/images/Autopsy/FTK/5.png"><br>
Rellenaremos los datos necesarios para detallar el caso en la siguiente ficha.<br>
<img alt="esquema" src="/images/Autopsy/FTK/6.png"><br>
Y por ultimo añadiremos el destino de la copia e indicaremos su nombre. Podemos personalizar también el tamaño de los fragmentos.<br>
<img alt="esquema" src="/images/Autopsy/FTK/7.png"><br>
Una vez haya terminado el proceso se presentará la siguiente ventana. Desde la que podremos ver su <strong>código Hash</strong> asignado y calculado con las funciones <strong>MD5 y SHA1</strong>. También veremos sus propiedades como numero de sectores y si hay algún bloque corrupto en el disco.<br>
Es muy importante apuntar el Código Hash ya que aquí comienza la <strong>Cadena de Custodia</strong> de este elemento, siendo identificado en todo momento y comprobando su integridad con esta cadena de caracteres.<br>
<img alt="esquema" src="/images/Autopsy/Fincopiadohash.png"><br>
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
<img alt="esquema" src="/images/Autopsy/Fincopianohash.png"><br>
Por ultimo podemos obtener un resumen en formato texto de esta tarea:<br>
Nos proporcionará información extra muy útil en nuestra tarea como forenses.<br>
<img alt="esquema" src="/images/Autopsy/Summary.png"></p>
<h2 id="autopsy">Autopsy</h2>
<p>Comenzaremos abriendo la herramienta. Se nos solicitará información y datos para crear un nuevo caso de investigación forense. Haremos click en “New Case”.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/0.png"><br>
Aquí personalizaremos y añadiremos la ruta de almacenamiento del caso que hemos creado y daremos algunos detalles del caso que vamos a analizar:<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/1.png"><br>
Tras hacer click en Next completamos la información restante con los <strong>máximos detalles</strong> posibles y le damos a &ldquo;Finish&rdquo;.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/2.png"><br>
Añadiremos como origen de datos la copia virtual del disco desde <strong>“Add Datasource”</strong>. Rellenaremos los datos según nuestra conveniencia. Por el momento el Host lo mantendremos por defecto.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/3.png"><br>
Como data source type elegiremos <strong>“Disk Image or VM file”</strong> que sera el correspondiente a la copia que hemos realizado.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/4.png"><br>
Buscaremos la ruta de la copia que hemos realizado y seleccionaremos el primer elemento de la copia.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/5.png"><br>
Nota: Puede variar según el tipo de copia que hayamos realizado (DD Raw SMART E01 etc)<br>
Si lo deseamos para aumentar el nivel de integridad podemos añadir los resultados de las <strong>funciones Hash</strong> calculadas previamente.<br>
Haremos click en next y veremos una nueva ventana en la que se presentan todos los módulos con los que podemos trabajar desde autopsy. Deseleccionaremos todos y marcaremos <strong>“Recent Activity”</strong> para reducir el tiempo de análisis.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/6.png"><br>
Iniciaremos el proceso de extracción de datos y esperaremos a los resultados.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/7.png"><br>
<img alt="esquema" src="/images/Autopsy/Autopsy/8.png"><br>
Vemos que ha finalizado sin problemas y procederemos al <em>análisis en profundidad</em>.<br>
Se presentará una interfaz en la que se podrá identificar de manera visual todos los datos extraidos de la imagen de disco proporcionada:<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/9.png"><br>
Iremos poco a poco desmenuzando la información obtenida.<br>
Primero se proporcionará la <em>estructura global</em> de datos del disco, pudiendo ver <em>particiones, estructuras de carpetas y datos detallados</em> del sistema de archivos:<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/10.png"><br>
Podremos ver los detalles en <strong>“Data Artifacts”</strong> . <em>Sistema Operativo, nombre del equipo, nombre del propietario, etiqueta del disco</em> etc.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/11.png"><br>
Desde “File views” observaremos una clasificacion de archivos por extensiones desde la que podremos sacar <strong>imagenes, videos, bases de datos, documentos HTML o de texto plano etc</strong>.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/12.png"><br>
De esta sección queda a destacar la gran cantidad de imágenes que existen (las cuales incluyen iconos e imágenes del sistema) y la cantidad de documentos HTML lo cual nos hace pensar que hosteaba algún tipo de <em>servidor</em>.<br>
Si investigamos más a fondo en los documentos HTML veremos nombres <em>git</em> lo que nos hace pensar que tiene relacion con el software <strong>“Git”</strong> o hostea este tipo de estructuras.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/13.png"><br>
Más adelante tenemos una seccion muy interesante llamada <strong>“Deleted Files”</strong> la cual llama la atencion investigar, teniendo en cuenta que se le haya podido escapar algún documento eliminado que no ha borrado correctamente. Cambien incluye documentación temporal o de inicio del equipo.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/14.png"><br>
Pasamos a una sección muy interesante, <strong>“MB File Size”</strong>. Aqui se dividen los archivos por tamaño, pudiendo clasificarse en:</p>
<ul>
<li><strong>MB 50 – 200</strong> → Archivos pequeños como configuraciones o documentos personales de texto o trabajos particulares. Muy interesantes para investigar configuraciones personalizadas o documentos con información más personal. También ejecutables o accesos directos.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/15.png"></li>
<li><strong>MB 200 – 1GB</strong> → Este rango incluirá desde documentos pesados como librerias contundentes hasta programas instalados en el equipo.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/16.png"></li>
<li>**MB 1GB+ **→ Estos documentos tan pesados son posibles bases de datos del sistema, como hemos visto previamente en el apartado de archivos HTML, aquí aparecerán los archivos de las BBDD de la web. También aparecerán almacenamientos de paginación de programas grandes en los que la memoria RAM se saturaba.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/17.png"><br>
Pasamos a la seccion <strong>“Data Artifacts”</strong>. Aqí se clasificarán los datos obtenidos en diferentes grupos:<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/18.png"><br>
Destacaremos <em>Programas instalados, Documentos Recientes, Programas corriendo, USB Device Attached, Web Accounts, Coockies, Downloads e Historial y por ultimo Web Form Autofill</em>.</li>
<li><strong>Programas Instalados</strong>. Una seccion que nos indicará el tipo de trabajo que realizaba el usuario y las tareas que desempeñaba. Podemos ver SOFTWARE como HomeBank o Money Manager que nos indica el manejo de cuentas bancarias.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/19.png"></li>
<li><strong>Documentos Recientes</strong>. Una seccion util, mostrará su actividad reciente. Podemos observar que trabajaba con archivos de Github, corroborando lo visto previamente en HTML Docs.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/20.png"></li>
<li><strong>Programas Corriendo</strong>. Aqui veremos los programas que estaban iniciados en el sistema cuando se tomó la imagen, se mostrarán los servicios de los que se disponia como Git o GithubDesktop.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/21.png"><br>
También aparece Chrome.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/22.png"></li>
<li><strong>USB Device Attached</strong>. Veremos los dispositivos USB externos con los que trabajaba, es interesante de cara a la información no contenida en el equipo y posiblemente relacionada con el escenario. Veremos sus ID’s e información de los dispositivos para comprara con los que se han encontrado en la escena.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/23.png"></li>
<li><strong>Web Accounts, Cookies e Historial</strong>. Aqui podremos ver los diversos datos de navegación del usuario, como las paginas en las que se ha registrado y su nombre de usuario o correo (<a href="mailto:bart.simpson_springfield@hotmail.com">bart.simpson_springfield@hotmail.com</a>) (Github)<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/24.png"><br>
Tambien veremos las cookies, pudiendo dar pistas sobre que webs se ha navegado<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/25.png"><br>
Y el historial que indica el proceso de navegación. (Principalmente Github)<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/26.png"></li>
<li>Por ultimo tenemos la sección <strong>Web Form Autofill</strong>. Que mostrará la información guardada en el navegador para auto rellenar los formularios, esta es información muy sensible, ya que implica datos personales del usuario. Puede ser útil de cara a una investigación pero ha de ser manejada con cuidado.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/27.png"><br>
En el apartado de  <em>“Analisys Results”</em> tenemos Web Account type, desde donde podremos obtener tambien información muy valiosa, como las <strong>preguntas de seguridad</strong> del usuario Bart:<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/28.png"><br>
Queda a destacar que según vamos haciendo el proceso de investigación podremos marcar con <strong>“Tags”</strong> los artefactos que nos sugieran infomación interesante. Estos se reflejarán en la ultima seccion Tags. Un ejemplo:<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/29.png"><br>
<img alt="esquema" src="/images/Autopsy/Autopsy/30.png"></li>
</ul>
<h2 id="report">Report</h2>
<p>Generaremos un reporte para poder ver los datos mas claramente desde <strong>“Generate Report”</strong>.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/31.png"><br>
Usaremos el formato <strong>HTML</strong>.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/32.png"><br>
Seleccionamos el <strong>Data source</strong>.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/33.png"><br>
Y todos los resultados especificados, en nuestro caso las marcas<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/34.png"><br>
Esperaremos a la generacion<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/35.png"><br>
Una vez generado lo abriremos en nuestro navegador para su mejor visualización.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/36.png"></p>
<h3 id="incidencias">INCIDENCIAS.</h3>
<p>Sin Incidencias notificadas.</p>
<h3 id="bibliografía">BIBLIOGRAFÍA.</h3>
<ul>
<li><a href="https://www.autopsy.com/">https://www.autopsy.com/</a></li>
</ul>
]]></content></item><item><title>LanTap</title><link>https://kerneloop.github.io/posts/lantap/</link><pubDate>Mon, 18 Aug 2025 21:21:43 +0200</pubDate><guid>https://kerneloop.github.io/posts/lantap/</guid><description>En este ejercicio vamos a preparar un intermediario en una red, a traves de este intermediario seremos capaces de interceptar todo el trafico que pase por el nodo de conexion. Este tipo de prácticas son útiles a la hora de capturar y monitorizar de una manera precisa todo el trafico. Tambien es conocido como un método de ataque invasivo conocido como &amp;ldquo;Sniffing - Lan Tap&amp;rdquo; en el que un atacante recogerá y almacenará los paquetes que reciba y envie la victima para su posterior analisis.</description><content type="html"><![CDATA[<p>En este ejercicio vamos a preparar un intermediario en una red, a traves de este intermediario seremos capaces de <em><strong>interceptar</strong></em> todo el <em><strong>trafico</strong></em> que pase por el nodo de conexion. Este tipo de prácticas son útiles
a la hora de capturar y monitorizar de una manera precisa todo el trafico. Tambien es conocido como un método de ataque invasivo conocido como &ldquo;Sniffing - Lan Tap&rdquo; en el que un <em><strong>atacante</strong></em> recogerá y almacenará
los paquetes que reciba y envie la victima para su posterior analisis. A traves de este método un atacante puede obtener de manera <em><strong>ilegitima</strong></em> <em><strong>contraseñas</strong></em>, nombres de <em><strong>usuario</strong></em> e información <em><strong>sensible</strong></em> de un usuario.</p>
<h2 id="esquema">Esquema</h2>
<p>Partiremos del esquema con el que vamos a trabajar:
<img alt="esquema" src="/images/LanTap/Schema.png"></p>
<p>Podemos observar que el momento de intercepción de datos se encuentra entre el <em><strong>firewall</strong></em> y el resto de equipos conectados al <em><strong>switch</strong></em>. De esta manera podremos interceptar tod el trafico que fluya hacia los
equipos que se encuentran dentro de la <em><strong>red</strong></em>.</p>
<h2 id="preparacion">Preparacion</h2>
<p>Procederemos a cortar el cable de <em><strong>conexion</strong></em> entre el <em><strong>router</strong></em> y el <em><strong>switch</strong></em>, lo pelaremos con una herramienta de crimpado y separaremos los cables que se encuentran en el interior del <em><strong>RJ-45</strong></em>.
Siguiendo esta tabla podremos ver el codigo de colores de un cable de conexion RJ-45 estandart.</p>
<p><em><strong>OJO</strong></em> -&gt; No confundir con cable de conexion <em><strong>CRUZADO</strong></em>, tiene otro tipo de orden de colores y usos.<br>
<img alt="esquema" src="/images/LanTap/colortable.png"></p>
<p>Pelaremos los cables y los volveremos a conectar, de manera que el cobre de las conexiones <em><strong>NARANJA</strong></em>, <em><strong>NARANJA-BLANCO</strong></em>, <em><strong>VERDE</strong></em> y <em><strong>VERDE-BLANCO</strong></em> queden expuestos al contacto fisico.<br>
<img alt="esquema" src="/images/LanTap/wires.png"></p>
<p>Pelaremos otros dos cables <em><strong>RJ-45</strong></em> de la siguiente manera:</p>
<h3 id="cable-1">Cable 1</h3>
<ul>
<li>Extremo 1 -&gt; Clavija estandart <em><strong>RJ-45</strong></em>.</li>
<li>Extremo 2 -&gt; Conexion NARANJA y NARANJA-BLANCO expuesto.</li>
</ul>
<h3 id="cable-2">Cable 2</h3>
<ul>
<li>Extremo 1 -&gt; Clavija estandart <em><strong>RJ-45</strong></em>.</li>
<li>Extremo 2 -&gt; Conexion VERDE y VERDE-BLANCO expuesto.</li>
</ul>
<p>De esta manera uniremos las conexiones de <em><strong>Cable 1</strong></em> a los polos naranjas del cable de conexion entre el router y el switch y el <em><strong>Cable 2</strong></em> a los polos verdes del mismo.</p>
<p><img alt="esquema" src="/images/LanTap/howitwork.png"></p>
<p>Necesitaremos dos adaptadores de RJ-45 a <em><strong>USB</strong></em> para conectarlos al equipo que va a monitorear el trafico, los conectaremos respectivamente e iniciaremos la aplicacion Wireshark previamente instalada.</p>
<p>Veremos que aparecerán los dos adaptadores en el inicio de <em><strong>Wireshark</strong></em>, los seleccionaremos manteniendo pulsada la tecla CRTL e iniciaremos la monitorización.</p>
<p><img alt="esquema" src="/images/LanTap/twoadapters.png"></p>
<h2 id="monitorización">Monitorización</h2>
<p>Una vez hayamos iniciado el rastreo de paquetes podremos ver como aparecen en pantalla todos los <em><strong>paquetes</strong></em> que pasan a traves de la conexion entre el router y el switch hacia la red que hemos preparado.
Se ve indicado el <em><strong>origen</strong></em> y <em><strong>destino</strong></em> de cada paquete junto a su fecha de envio, <em><strong>protocolo</strong></em>, longitud e información.
<img alt="esquema" src="/images/LanTap/result.png"></p>
<p>Una vez lo deseemos, podremos finalizar la captura de paquetes para poder analizar más en detalle el <em><strong>trafico</strong></em> <em><strong>interceptado</strong></em> y analizar algun tipo de trafico sospechoso, indeseado o de dudosa procedencia.
Este archivo con la captura se podrá guardar en formato <em><strong>.pcapng</strong></em> para su posterior manejo.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Este método de análisis es muy interesante por parte de un <em><strong>atacante</strong></em> para interceptar el tráfico que se mueve en una red a la que se tiene acceso físico, es una metodología <em><strong>silenciosa</strong></em>,
no genera ningún tipo de <em><strong>registro</strong></em> y si esta bien preparada es <em><strong>imperceptible</strong></em> a ojos de un usuario común. Es un riesgo que algunas empresas/entornos han llegado a enfrentar en diversas situaciones,
por eso la <em><strong>seguridad</strong></em> <em><strong>fisica</strong></em> es tan <em><strong>crucial</strong></em> como la seguridad a nivel de software.</p>
]]></content></item><item><title>Data Diode</title><link>https://kerneloop.github.io/posts/datadiode/</link><pubDate>Mon, 18 Aug 2025 20:47:16 +0200</pubDate><guid>https://kerneloop.github.io/posts/datadiode/</guid><description>En este proyecto veremos lo que es un diodo de datos. Como bien indica en su nombre se trata de un conducto de informacion en un unico sentido. El objetivo será que el agente que envie informacion no sea capaz de recibirla, de manera que el sistema crítico se encontrará completamente aislado de comunicaciones externas y será capaz de transmitir información para su monitorización, registro y gestión.
Para empezar debemos entender que protocolos de comunicación vamos a utilizar en este ejercicio.</description><content type="html"><![CDATA[<p>En este proyecto veremos lo que es un <strong>diodo de datos</strong>. Como bien indica en su nombre se trata de un conducto de informacion en un unico sentido.
El objetivo será que el agente que envie informacion no sea capaz de recibirla, de manera que el sistema crítico se encontrará completamente aislado de comunicaciones
externas y será capaz de transmitir información para su monitorización, registro y gestión.</p>
<p>Para empezar debemos entender que protocolos de comunicación vamos a utilizar en este ejercicio.</p>
<p><img alt="Architecture1" src="/images/DataDiode/tcpudpblack.jpg"></p>
<h3 id="tcp">TCP</h3>
<p>El protocolo TCP (Transmission Control Protocol) es un protocolo fundamental en la comunicación de datos a través de redes informáticas garantizando una transmisión confiable y ordenada de la información entre dispositivos.
Tiene un funcionamiento que se divide principalmente en <strong>tres partes:</strong></p>
<ul>
<li><strong>SYN</strong> -&gt; El cliente inicia la conexión enviando un paquete SYN al servidor. Este paquete contiene un número de secuencia aleatorio que se utilizará para identificar los paquetes enviados por el cliente.</li>
<li><strong>SYN ACK</strong> -&gt; El servidor, al recibir el SYN, responde con un paquete SYN-ACK. Este paquete incluye el número de secuencia del cliente incrementado en uno y un nuevo número de secuencia para la comunicación del servidor al cliente.</li>
<li><strong>ACK</strong> -&gt; El cliente recibe el SYN-ACK y envía un último paquete ACK al servidor, confirmando la conexión y utilizando el número de secuencia del servidor incrementado en uno.</li>
</ul>
<p>Como podemos ver, en esta comunicacion se requiere contacto entre los dos agentes, tanto como para iniciar la conexion como para finalizarla.</p>
<h3 id="udp">UDP</h3>
<p>El protocolo UDP (User Datagram Protocol) es un protocolo de red que permite el envío de datos sin necesidad de establecer una conexión previa entre emisor y receptor, a diferencia de TCP.
Esto significa que <strong>UDP</strong> envía datagramas (paquetes de datos) de forma independiente y no garantiza la recepción, el orden ni la integridad de los datos. Su principal ventaja es la velocidad y eficiencia, ideal para aplicaciones donde la latencia es crítica, como streaming de video o juegos online.</p>
<p><strong>Funcionamiento:</strong></p>
<ul>
<li><strong>UDP</strong> divide los datos en paquetes (datagramas) y los envía a la dirección IP y puerto de destino, sin establecer una conexión formal.</li>
<li>No hay establecimiento de conexión previo ni confirmación de recepción, lo que permite una comunicación rápida.</li>
<li><strong>UDP</strong> no garantiza que los datagramas lleguen a destino, ni que lleguen en el orden correcto o sin errores.</li>
</ul>
<h2 id="entornos-de-uso">Entornos de uso</h2>
<p>Este tipo de dispositivos se situan en entornos críticos como Plantas Industriales/Nucleares, laboratorios de ciberseguridad o zonas de máxima seguridad.<br>
Gracias a esta metodología seremos capaces de monitorizar desde un SOC exterior todo el entorno al otro lado del Diodo, pudiendo registrar y recibir lecturas
de temperatura en centrales industriales o evitando que un virus informático logre una conexion externa con un atacante mientras se hacen pruebas.</p>
<p><img alt="Architecture2" src="/images/DataDiode/datadiodetap.webp"></p>
<h2 id="equipo-y-montaje">Equipo y Montaje</h2>
<p>Actualmente existen varios proveedores de dispositivos que realizan esta funcion y esta implementada directamente en el hardware que distribuyen.<br>
Nosotros utilizaremos una solucion más económica y casera a traves de convertidores de Fibra Óptica a Cobre. Es importante que estos convertidores dispongan de dos
entradas (Rx) y salidas (Tx) ya que en esa division nos permitirá separar el tráfico para hacer el diodo.</p>
<p><img alt="Convertidores" src="/images/DataDiode/Convertidor.jpg"></p>
<p>Una vez tengamos estos dispositivos procederemos a conectar la fibra y el cobre de la siguiente manera:<br>
<img alt="Architecture3" src="/images/DataDiode/architecture.png"></p>
<h3 id="funcionamiento">Funcionamiento</h3>
<p>Veremos que el equipo que envía se conecta directamente al equipo que recibe a traves de Tx y Rx sin embargo
hay un convertidor de fibra a cobre entre los dos equipos que no tiene salida de cobre, este será el &ldquo;vacio&rdquo;.
El equipo receptor intentará dar una respuesta, comprobará que la puede enviar, y la enviará a este &ldquo;vacio&rdquo; a través de Tx a Rx pero no será recibida por ningun equipo.<br>
Este engaño se produce tambien para el equipo que envia ya que realizará una comprobacion en Rx para ver si puede recibir informacion en la red preparada, al estar conectado el cable
de fibra interpretará que la conexion es correcta pero nunca recibirá nada ya que viene de el convertidor &ldquo;vacio&rdquo;.</p>
<p><strong>¡IMPORTANTE!</strong><br>
Los dos equipos no disponen de ningun servidor DHCP ni de ninguna figura intermediaria que sea capaz de redireccionar el trafico en la conexion.
Deberemos de preparar una direccion IP para cada uno y añadir en las tablas ARP las direcciones MAC de los dos equipos.<br>
Utilizaremos el siguiente comando en una consola con permisos de administrador:</p>
<pre tabindex="0"><code class="language-CMD/POWERSHELL" data-lang="CMD/POWERSHELL">arp -s {direccion IP} {direccion mac}
</code></pre><p>Para comprobar que se ha añadido correctamente usaremos <strong>arp -a</strong>.</p>
<h2 id="puesta-en-marcha">Puesta en marcha</h2>
<p>Utilizaremos un rastreador de paquetes en el equipo que recibe de manera que cuando establezcamos una conexion TCP podramos ver la recepcion del paquete y un envio fallido de respuesta, por el contrario
en una conexion UDP podremos ver la recepcion del paquete y ninguna respuesta.</p>
<p>Existen multiples herramientas para rastrear esta conexion como <em><strong>tcpdump</strong></em> que funciona a nivel de consola o <em><strong>wireshark</strong></em> que posee una interfaz más amigable.</p>
<p>En este caso utilizaremos <em><strong>wireshark</strong></em> y lo prepararemos en la máquina receptora escuchando en la interfaz en la que estén conectados los equipos.</p>
<p>Ahora desde &ldquo;CMD&rdquo; enviaremos el comando de ping desde la maquina que envia a la que recibe, podremos ver como aparecen los mensajes en la interfaz, su origen y direccion.</p>
<p><img alt="Ping" src="/images/DataDiode/ping.png"></p>
<p>Podremos ver como la maquina receptora intenta devolver el ping, sin embargo en el equipo que inicia la conexion no estamos recibiendo respuesta.</p>
<p><img alt="Pingmal" src="/images/DataDiode/pingmal.png"></p>
<p>En cuanto a la conexion UDP enviaremos un mensaje al receptor con el la herramienta netcat y el comando <em><strong>nc64.exe</strong></em> <em><strong>-u</strong></em> <em><strong>192.168.2.12</strong></em> <em><strong>1234</strong></em>. Desde el lado del receptor estaremos escuchando en wireshark y abriremos una consola
de comandos &ldquo;CMD&rdquo; y escribiremos el siguiente comando <em><strong>nc64.exe</strong></em> <em><strong>-ulvp</strong></em> <em><strong>1234</strong></em>.</p>
<p>Una vez establecida esta conexion procederemos a escribir cualquier caracter en la consola del equipo que envia, podremos ver como aparece en la consola del que recibe. Desde <em><strong>wireshark</strong></em> se verá como llega el paquete con
su longitud y protocolo UDP.</p>
<p>Consola:
<img alt="UDPLetra" src="/images/DataDiode/udpletra.png"></p>
<p>Wireshark:
<img alt="UDP" src="/images/DataDiode/udp.png"></p>
<p>El flujo de los datos de este procedimiento será de la siguiente manera.</p>
<p><img alt="Architecture4" src="/images/DataDiode/architecturediode.png"></p>
<h2 id="conclusion">Conclusion</h2>
<p>Este tipo de tecnologías se utilizan en entornos muy críticos, es imprescindible conocer el funcionamiento de las conexiones <em><strong>TCP</strong></em> y <em><strong>UDP</strong></em> que se van a utilizar para poder comprender el flujo de los datos.<br>
De esta manera aseguramos un sistema en el que podremos recibir o enviar informacion exclusivamente en un sentido. A diferencia de un firewall que se regula por las reglas establecidas por el administrador de sistemas en cuestion,
este metodo asegura una imposibilidad de flujo más que <em><strong>logica</strong></em> &hellip;. <em><strong>ES</strong></em> <em><strong>FISICA!!</strong></em> El acceso a el sistema por la parte bloqueada del diodo esta restringida sin acceso fisico a la instalacion, lo cual da un <em><strong>grado</strong></em> <em><strong>de</strong></em> <em><strong>seguridad</strong></em> <em><strong>dificilmente</strong></em>
<em><strong>evadible</strong></em>.</p>
]]></content></item><item><title>ThunderDB</title><link>https://kerneloop.github.io/posts/thuderdb/</link><pubDate>Sun, 29 Jun 2025 20:45:04 +0200</pubDate><guid>https://kerneloop.github.io/posts/thuderdb/</guid><description>Introduccion En este proyecto realizaremos un manejo de parametros de los rayos y truenos de la página web Blitzortung a traves de un web socket.
Lo primero es acceder a la web, para ver el websocket que utilizaremos. Presionando la tecla abriremos el panel de desarrollador y nos dirigiremos al apartado &amp;ldquo;Network&amp;rdquo; &amp;ldquo;Socket&amp;rdquo;.
Desde aquí podremos identificar en la seccion &amp;ldquo;Name&amp;rdquo; el websocket que vamos a utilizar.
WEB SOCKET-&amp;gt; &amp;ldquo;wss://ws1.blitzortung.org/&amp;rdquo;.</description><content type="html"><![CDATA[<h3 id="introduccion">Introduccion</h3>
<p>En este proyecto realizaremos un manejo de parametros de los <strong>rayos</strong> y <strong>truenos</strong> de la página web <a href="https://www.blitzortung.org">Blitzortung</a>
a traves de un <em>web socket</em>.<br>
Lo primero es acceder a la web, para ver el websocket que utilizaremos. Presionando la tecla <!-- raw HTML omitted --> abriremos el panel de desarrollador y nos dirigiremos al apartado &ldquo;Network&rdquo; &ldquo;Socket&rdquo;.</p>
<p><img alt="Socket" src="/images/ThunderDB/socket.png"></p>
<p>Desde aquí podremos identificar en la seccion &ldquo;Name&rdquo; el websocket que vamos a utilizar.<br>
<strong>WEB SOCKET</strong>-&gt; &ldquo;wss://ws1.blitzortung.org/&rdquo;.<br>
Veremos que esta constantemente recibiendo informacion, sin embargo podremos ver que está cifrada.</p>
<p>Investigando la forma de trabajo del websocket identificaremos el metodo que utiliza para iniciar la conexion.
Como requisito necesitará que le pasemos en formato JSON el contenido {&ldquo;a&rdquo;:111}.<br>
Una vez se ha realizado comenzará a enviar todos los eventos.<br>
Bien, con un poco de codigo simple relacionado con Web-Sockets seremos capaces de recibir esta informacion. Ahora el problema es que esta obfuscada.<br>
Buscando un poco por internet y analizando el formato podremos descubrir que se trata de obfuscacion LZW.</p>
<p>Procederemos a generar un codigo de python que maneje toda la informacion y sea capaz de deobfuscar los datos que recibimos para su tratamiento.</p>
<p>Utilizaremos las librerias <strong>websocket y json</strong>.</p>
<p><strong>La funcion de deobfuscamiento será la siguiente:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decoder</span>(encoded_str):
</span></span><span style="display:flex;"><span>    e <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>    d <span style="color:#f92672">=</span> list(encoded_str)
</span></span><span style="display:flex;"><span>    c <span style="color:#f92672">=</span> d[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>    f <span style="color:#f92672">=</span> c
</span></span><span style="display:flex;"><span>    g <span style="color:#f92672">=</span> [c]
</span></span><span style="display:flex;"><span>    h <span style="color:#f92672">=</span> <span style="color:#ae81ff">256</span>
</span></span><span style="display:flex;"><span>    o <span style="color:#f92672">=</span> h
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(d)):
</span></span><span style="display:flex;"><span>        a <span style="color:#f92672">=</span> ord(d[i])
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> a <span style="color:#f92672">&lt;</span> h:
</span></span><span style="display:flex;"><span>            a_str <span style="color:#f92672">=</span> d[i]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> a <span style="color:#f92672">in</span> e:
</span></span><span style="display:flex;"><span>            a_str <span style="color:#f92672">=</span> e[a]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            a_str <span style="color:#f92672">=</span> f <span style="color:#f92672">+</span> c
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        g<span style="color:#f92672">.</span>append(a_str)
</span></span><span style="display:flex;"><span>        c <span style="color:#f92672">=</span> a_str[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>        e[o] <span style="color:#f92672">=</span> f <span style="color:#f92672">+</span> c
</span></span><span style="display:flex;"><span>        o <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        f <span style="color:#f92672">=</span> a_str
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join(g)<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#39;latin1&#39;</span>)
</span></span></code></pre></div><p>Nuestro codigo ha de tener una funcion para mostrar la información de una manera visible, así comprobaremos que estamos tratando con los datos correctos.<br>
Para ello mostraremos tanto el codigo obfuscado y el deobfuscado.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">on_message</span>(ws, message):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Mensaje recibido (texto):&#34;</span>, message[:<span style="color:#ae81ff">100</span>], <span style="color:#e6db74">&#34;...&#34;</span>)  <span style="color:#75715e"># Mostrar un resumen</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Aplicar LZW decoder al mensaje completo (texto plano recibido)</span>
</span></span><span style="display:flex;"><span>    decoded_bytes <span style="color:#f92672">=</span> decoder(message)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>        decoded_text <span style="color:#f92672">=</span> decoded_bytes<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;utf-8&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">UnicodeDecodeError</span>:
</span></span><span style="display:flex;"><span>        decoded_text <span style="color:#f92672">=</span> decoded_bytes<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;latin1&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Texto decodificado:&#34;</span>, decoded_text[:<span style="color:#ae81ff">200</span>], <span style="color:#e6db74">&#34;...&#34;</span>)  <span style="color:#75715e"># Mostrar un resumen</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>        data <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>loads(decoded_text)
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Datos JSON parseados correctamente:&#34;</span>, data)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">except</span> json<span style="color:#f92672">.</span>JSONDecodeError:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;No se pudo parsear JSON después de decodificar&#34;</span>)
</span></span></code></pre></div><p>Una vez seamos capaces de obtener los datos decodificados podremos empezar a trabajar con ellos!
Creando dos contenedores de <strong>Docker</strong> (Mysql y Grafana) le daremos forma y vida a estos datos obtenidos.</p>
<h3 id="mysql">MySQL</h3>
<ul>
<li>sudo docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=&lt;CONTRASEÑA&gt; &ndash;name=mysql mysql</li>
</ul>
<h3 id="grafana">Grafana</h3>
<ul>
<li>sudo docker run -d -p 3000:3000 &ndash;name=grafana grafana/grafana-enterprise</li>
</ul>
<p>Partiremos de una instalacion predefinida con usuario admin en MySQL y una configuracion por defecto en Grafana.</p>
<p>Para la configuracion de la base de datos cargaremos este script al contenedor de docker a traves de &ldquo;Mysql-Client&rdquo;.</p>
<p><strong>comandos.sql</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-MySql" data-lang="MySql"><span style="display:flex;"><span><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">DATABASE</span> <span style="color:#66d9ef">IF</span> <span style="color:#66d9ef">EXISTS</span> thunder;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">DATABASE</span> thunder;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">USE</span> thunder;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#66d9ef">IF</span> <span style="color:#66d9ef">EXISTS</span> main_data;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#a6e22e">main_data</span> (
</span></span><span style="display:flex;"><span>  id <span style="color:#66d9ef">BIGINT</span> <span style="color:#66d9ef">AUTO_INCREMENT</span> <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">time</span> <span style="color:#66d9ef">BIGINT</span>,
</span></span><span style="display:flex;"><span>  lat <span style="color:#66d9ef">DOUBLE</span>,
</span></span><span style="display:flex;"><span>  lon <span style="color:#66d9ef">DOUBLE</span>,
</span></span><span style="display:flex;"><span>  alt <span style="color:#66d9ef">INT</span>,
</span></span><span style="display:flex;"><span>  pol <span style="color:#66d9ef">INT</span>,
</span></span><span style="display:flex;"><span>  mds <span style="color:#66d9ef">INT</span>,
</span></span><span style="display:flex;"><span>  mcg <span style="color:#66d9ef">INT</span>,
</span></span><span style="display:flex;"><span>  status <span style="color:#66d9ef">INT</span>,
</span></span><span style="display:flex;"><span>  region <span style="color:#66d9ef">INT</span>,
</span></span><span style="display:flex;"><span>  delay <span style="color:#66d9ef">FLOAT</span>,
</span></span><span style="display:flex;"><span>  lonc <span style="color:#66d9ef">INT</span>,
</span></span><span style="display:flex;"><span>  latc <span style="color:#66d9ef">INT</span>
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#66d9ef">IF</span> <span style="color:#66d9ef">EXISTS</span> signals;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#a6e22e">signals</span> (
</span></span><span style="display:flex;"><span>  id <span style="color:#66d9ef">BIGINT</span> <span style="color:#66d9ef">AUTO_INCREMENT</span> <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span>,
</span></span><span style="display:flex;"><span>  main_data_id <span style="color:#66d9ef">BIGINT</span>,
</span></span><span style="display:flex;"><span>  sta <span style="color:#66d9ef">INT</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">time</span> <span style="color:#66d9ef">BIGINT</span>,
</span></span><span style="display:flex;"><span>  lat <span style="color:#66d9ef">DOUBLE</span>,
</span></span><span style="display:flex;"><span>  lon <span style="color:#66d9ef">DOUBLE</span>,
</span></span><span style="display:flex;"><span>  alt <span style="color:#66d9ef">INT</span>,
</span></span><span style="display:flex;"><span>  status <span style="color:#66d9ef">INT</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">FOREIGN</span> <span style="color:#66d9ef">KEY</span> (main_data_id) <span style="color:#66d9ef">REFERENCES</span> <span style="color:#a6e22e">main_data</span>(id)
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>Lo cargaremos con:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Bash" data-lang="Bash"><span style="display:flex;"><span>mysql -h &lt;IP&gt; -u root -p -vvv &lt; comandos.sql
</span></span></code></pre></div><p>Donde <!-- raw HTML omitted --> sera la direccion IP del contenedor de Docker.</p>
<p>Una vez configurada la base de datos accederemos al panel de Grafana desde Data Sources -&gt; Add New Data Source -&gt; Mysql<br>
Completaremos los campos necesarios con las credenciales indicadas.</p>
<p><img alt="Grafana" src="/images/ThunderDB/Grafana.png"></p>
<p>Nota: En caso de no disponer de un certificado TLS/SSL marcaremos la casilla que deshabilita la conexion segura.</p>
<p>Una vez conectada la base de datos MySql con Grafana procederemos a crear la Dashboard que muestre los datos.</p>
<p>Nos dirigiremos al apartado &ldquo;Dashboards&rdquo; y crearemos una nueva desde el boton &ldquo;New Dashboard&rdquo; y &ldquo;Add Visualization&rdquo;.</p>
<p>Nos solicitará un <strong>Data Source</strong> e introduciremos el que acabamos de crear con MySql.</p>
<p>Tras desplegarse correctamente deberemos crear una consulta que sea capaz de recoger los datos recibidos y mostrarlos en la grafica.<br>
Ejemplos:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-MySql" data-lang="MySql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">FROM_UNIXTIME</span>(<span style="color:#66d9ef">time</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">1000000000</span>) <span style="color:#66d9ef">AS</span> <span style="color:#66d9ef">time</span>, <span style="color:#75715e">-- si tu tiempo está en nanosegundos, ajusta la conversión
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  lat,
</span></span><span style="display:flex;"><span>  lon,
</span></span><span style="display:flex;"><span>  alt
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span> main_data
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> <span style="color:#66d9ef">time</span> <span style="color:#66d9ef">DESC</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">1000</span>;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Mysql" data-lang="Mysql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">FROM_UNIXTIME</span>(s.<span style="color:#66d9ef">time</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">1000000000</span>) <span style="color:#66d9ef">AS</span> <span style="color:#66d9ef">time</span>,
</span></span><span style="display:flex;"><span>  s.sta,
</span></span><span style="display:flex;"><span>  s.lat,
</span></span><span style="display:flex;"><span>  s.lon,
</span></span><span style="display:flex;"><span>  s.alt,
</span></span><span style="display:flex;"><span>  s.status
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span> signals s
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">JOIN</span> main_data m <span style="color:#66d9ef">ON</span> s.main_data_id <span style="color:#f92672">=</span> m.id
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> s.<span style="color:#66d9ef">time</span> <span style="color:#66d9ef">DESC</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">1000</span>;
</span></span></code></pre></div><p>Lanzando las consultas podremos ver que empiezan a mostrarse los datos en el Panle de Visualización.</p>
<p><img alt="Grafica" src="/images/ThunderDB/grafica.png"></p>
<h3 id="enhorabuena">Enhorabuena!</h3>
<p>Hemos conseguido almacenar una gran cantidad de datos y una visualización rápida y efectiva de ellos.<br>
Si eres un apasionado de los <strong>Truenos y Rayos</strong> es tu momento!</p>
<h3 id="conclusión">Conclusión</h3>
<p>A traves de un websocket podemos recibir muchisima información, con su adecuado manejo seremos capaces de una infinidad de cosas.<br>
Docker nos permite utilizar un entorno super optimizado y orientado a tareas especificas con su sistema de contenedores. Gracias a esto podemos desplegar diferentes entornos sin necesidad de sobrecargar nuestro equipo principal.<br>
Grafana es una herramienta muy potente de visualización de datos que de manera organizada y personalizada nos presentará la informacion que seamos capaces de cargar en todos los entornos de los que dispone.</p>
<p>Hasta la vista Hackers.<br>
Kerneloop.</p>
]]></content></item><item><title>Microtik Router</title><link>https://kerneloop.github.io/posts/microtik-router/</link><pubDate>Sun, 22 Jun 2025 11:51:30 +0200</pubDate><guid>https://kerneloop.github.io/posts/microtik-router/</guid><description>Que es Mikrotik MikroTik es una marca fabricante de equipos de red. Desarrolla y vende enrutadores de red cableados e inalámbricos, conmutadores de red, puntos de acceso, así como sistemas operativos y software auxiliar.
Porque Mikrotik Es reconocido, tiene un software llamado RouterOS, el cual nos permitirá un manejo amplio en todas las configuraciones que podamos imaginar! Con Mikrotik Puedes hacer Cualquier cosa.
Primeros Pasos Dispondremos de un Router Mikrotik hAP Lite para este laboratorio.</description><content type="html"><![CDATA[<h2 id="que-es-mikrotik">Que es Mikrotik</h2>
<p>MikroTik es una marca fabricante de equipos de red. Desarrolla y vende enrutadores de red cableados e inalámbricos, conmutadores de red, puntos de acceso, así como sistemas operativos y software auxiliar.</p>
<h2 id="porque-mikrotik">Porque Mikrotik</h2>
<p>Es reconocido, tiene un software llamado RouterOS, el cual nos permitirá un manejo amplio en todas las configuraciones que podamos imaginar!
Con Mikrotik Puedes hacer <em><strong>Cualquier cosa</strong></em>.</p>
<h2 id="primeros-pasos">Primeros Pasos</h2>
<p>Dispondremos de un Router Mikrotik hAP Lite para este laboratorio. Es versatil, comodo y muy potente.
Precio actual -&gt; 20-30 Euros.</p>
<p>El primer paso es conectar a tu equipo <strong>Windows</strong> o <strong>Linux</strong> a traves de un cable RJ45 al primer puerto del router.
Una vez se encienda el Led Verde accederemos al router a traves del programa <a href="https://mikrotik.com/download" title="Winbox">WinBox</a>.
Cuando haya iniciado deberá de aparecer una interfaz como esta. Tambien verás la direccion MAC de tu Mikrotik.</p>
<p><img alt="Mikrotik-Main" src="/images/Mikrotik-Routing/Main-Winbox.png"></p>
<p>Por defecto, las credenciales son <strong>Username:</strong> admin <strong>Password:</strong> vacía</p>
<p>Haremos click en conectar y nos solicitará unas nuevas credenciales.<br>
Una vez introducidas nos redireccionará al menu principal desde el que podremos configurar absolutamente TODO!</p>
<h3 id="enhorabuena">Enhorabuena!</h3>
<p>Has accedido por primera vez a tu Router.<br>
A partir de aqui todo son maravillas, comienza tu exploración con el Networking.</p>
]]></content></item><item><title>Hello World</title><link>https://kerneloop.github.io/posts/hello-world/</link><pubDate>Sat, 21 Jun 2025 00:20:14 +0200</pubDate><guid>https://kerneloop.github.io/posts/hello-world/</guid><description>Hola Mundo. ¿Acaso no es asi como empieza todo?
Es impresionante como un hola puede romper esa barrera entre el no puedo y el primer paso. Esa barrera que se hace tan grande y fría como un muro. La reducimos con un poquito de nosotros cada día, un ratito libre con un café por las mañanas, en una escapada para merendar&amp;hellip;.. La rutina hace al monje.
Poco a poco ire publicando esos pequeños pasitos que iré dando en mis ratos libes, espero que disfrutes del proceso tanto como yo!</description><content type="html"><![CDATA[<h2 id="hola-mundo">Hola Mundo.</h2>
<p>¿Acaso no es asi como empieza todo?</p>
<p>Es impresionante como un hola puede romper esa barrera entre el no puedo y el primer paso.
Esa barrera que se hace tan grande y fría como un muro. La reducimos con un poquito de nosotros cada día,
un ratito libre con un café por las mañanas, en una escapada para merendar&hellip;.. La rutina hace al monje.</p>
<p>Poco a poco ire publicando esos pequeños pasitos que iré dando en mis ratos libes, espero que disfrutes del proceso tanto como yo!</p>
<p>Kerneloop.</p>
]]></content></item></channel></rss>