<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Kerneloop</title><link>https://kerneloop.github.io/posts/</link><description>Recent content in Posts on Kerneloop</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Sat, 07 Feb 2026 14:25:36 +0100</lastBuildDate><atom:link href="https://kerneloop.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Preparacion de un cluster de Kubernetes con Kubeadm</title><link>https://kerneloop.github.io/posts/kubernetescontainerd/</link><pubDate>Sat, 07 Feb 2026 14:25:36 +0100</pubDate><guid>https://kerneloop.github.io/posts/kubernetescontainerd/</guid><description>DESCRIPCIÓN. Preparación de clúster de Kubernetes para Certificación CKA.
Direcciones IP:
master -&amp;gt; 192.168.0.54
worker1 -&amp;gt; 192.168.0.56
worker2 -&amp;gt; 192.168.0.59
REQUISITOS. Contiene las siguientes especificaciones:
SISTEMA OPERATIVO -&amp;gt; Ubuntu Server (Minimal)
HARDWARE (Minimun) -&amp;gt; 2 Core CPU &amp;amp; 4 GB RAM
SOFTWARE -&amp;gt; ContainerD – Kubernetes (k8s)
La estructura del cluster será la siguiente Procedimiento Partiremos de una instalación mínima (Sin Interfaz Gráfica) en Ubuntu Server LTS 24.X. Como motor de ejecución de contenedores usaremos ContainerD.</description><content type="html"><![CDATA[<h2 id="descripción">DESCRIPCIÓN.</h2>
<p>Preparación de clúster de Kubernetes para Certificación CKA.<br>
Direcciones IP:<br>
<strong>master</strong> -&gt; 192.168.0.54<br>
<strong>worker1</strong> -&gt; 192.168.0.56<br>
<strong>worker2</strong> -&gt; 192.168.0.59</p>
<h2 id="requisitos">REQUISITOS.</h2>
<p>Contiene las siguientes especificaciones:</p>
<p>SISTEMA OPERATIVO -&gt; Ubuntu Server (Minimal)<br>
HARDWARE (Minimun) -&gt; 2 Core CPU &amp; 4 GB RAM<br>
SOFTWARE -&gt; ContainerD – Kubernetes (k8s)</p>
<h2 id="la-estructura-del-cluster-será-la-siguiente">La estructura del cluster será la siguiente</h2>
<p><img alt="esquema" src="/images/kubernetes/preparacion/1.png"></p>
<h2 id="procedimiento">Procedimiento</h2>
<p>Partiremos de una instalación mínima (Sin Interfaz Gráfica) en <strong>Ubuntu Server LTS 24.X</strong>.
Como motor de ejecución de contenedores usaremos ContainerD.
Es un entorno más ligero ya que no utiliza Docker al completo, solo la parte que virtualizará.
Iremos paso a paso realizando la instalación y posteriormente iniciando el Clúster. También uniremos dos nodos trabajadores que se podrán comunicar.</p>
<h2 id="instalación-containerd">Instalación Containerd</h2>
<h3 id="actualizamos-repositorios">Actualizamos repositorios</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt upgrade -y
</span></span></code></pre></div><h3 id="desinstalamos-posibles-conflictos">Desinstalamos posibles conflictos</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt remove <span style="color:#66d9ef">$(</span>dpkg --get-selections docker.io docker-compose docker-compose-v2 docker-doc podman-docker containerd runc | cut -f1<span style="color:#66d9ef">)</span>
</span></span></code></pre></div><h3 id="instalamos-paquetes">Instalamos paquetes</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt update 
</span></span><span style="display:flex;"><span>sudo apt install ca-certificates curl runc apt-transport-https ca-certificates curl gnupg2 software-properties-common git vim golang golang-go sudo gpg -y
</span></span></code></pre></div><h3 id="quitamos-la-memoria-swap-y-activamos-modulos-de-red">Quitamos la memoria swap y activamos modulos de red</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo swapoff -a
</span></span><span style="display:flex;"><span>sudo modprobe overlay
</span></span><span style="display:flex;"><span>sudo modprobe br<span style="color:#ae81ff">\_</span>netfilter
</span></span></code></pre></div><h3 id="comprobaremos-en-el-fichero-etcfstab-el-estado-de-la-memoria-swap">Comprobaremos en el fichero /etc/fstab el estado de la memoria swap:</h3>
<p><img alt="swapoff" src="/images/kubernetes/preparacion/2.png"></p>
<h3 id="configuracion-de-red-para-kubernetes">Configuracion de red para kubernetes</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo tee /etc/sysctl.d/kubernetes.conf
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&lt;&lt;EOF
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">net.bridge.bridge-nf-call-ip6tables = 1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">net.bridge.bridge-nf-call-iptables = 1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">net.ipv4.ip_forward = 1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">EOF</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo sysctl --system
</span></span></code></pre></div><h3 id="instalacion-de-docker">Instalacion de DOCKER</h3>
<h3 id="add-dockers-official-gpg-key">Add Docker&rsquo;s official GPG key:</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt update
</span></span><span style="display:flex;"><span>sudo apt install ca-certificates curl
</span></span><span style="display:flex;"><span>sudo install -m <span style="color:#ae81ff">0755</span> -d /etc/apt/keyrings
</span></span><span style="display:flex;"><span>sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
</span></span><span style="display:flex;"><span>sudo chmod a+r /etc/apt/keyrings/docker.asc
</span></span></code></pre></div><h3 id="añadimos-repositorios-necesarios">Añadimos Repositorios Necesarios:</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo tee /etc/apt/sources.list.d/docker.sources 
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&lt;&lt;EOF
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Types: deb
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">URIs: https://download.docker.com/linux/ubuntu
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Suites: $(. /etc/os-release &amp;&amp; echo &#34;${UBUNTU\_CODENAME:-$VERSION\_CODENAME}&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Components: stable
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Signed-By: /etc/apt/keyrings/docker.asc
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">EOF</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt update
</span></span><span style="display:flex;"><span>sudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin -y
</span></span></code></pre></div><h3 id="configuracion-de-containerd-para-kubernetes">Configuracion de containerd para kubernetes</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>containerd config default &gt; /etc/containerd/config.toml
</span></span></code></pre></div><h3 id="accederemos-a-la-configuración-y-ajustaremos-el-systemgroup">Accederemos a la configuración y ajustaremos el systemgroup</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vim /etc/containerd/config.toml
</span></span></code></pre></div><h3 id="modificamos-systemdcgroup-y-cambiamos-false-a-true">Modificamos SystemdCgroup y cambiamos false a true</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>plugins.<span style="color:#e6db74">&#34;io.containerd.grpc.v1.cri&#34;</span>.containerd.runtimes.runc<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">[</span>plugins.<span style="color:#e6db74">&#34;io.containerd.grpc.v1.cri&#34;</span>.containerd.runtimes.runc.options<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>    SystemdCgroup <span style="color:#f92672">=</span> true
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>systemctl restart containerd
</span></span></code></pre></div><h2 id="instalación-de-kubeadm">Instalación de Kubeadm</h2>
<h3 id="instalación-de-paquetes-kubeadm-por-defecto">Instalación de paquetes kubeadm por defecto</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt-get update
</span></span><span style="display:flex;"><span>curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.34/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
</span></span></code></pre></div><p><strong>NOTA!!</strong> Cambiar la versión de kubernetes según la instalación necesaria. En esta instalación utilizaremos la 1.34.</p>
<h3 id="añadimos-el-repositorio-con-la-versión-seleccionada">Añadimos el repositorio con la versión seleccionada</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.34/deb/ /&#39;</span> | sudo tee /etc/apt/sources.list.d/kubernetes.list
</span></span></code></pre></div><h3 id="actualizamos-repositorios-e-instalamos">Actualizamos repositorios e instalamos</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt-get update
</span></span><span style="display:flex;"><span>sudo apt-get install -y kubelet kubeadm kubectl
</span></span><span style="display:flex;"><span>sudo apt-mark hold kubelet kubeadm kubectl
</span></span><span style="display:flex;"><span>sudo systemctl enable --now kubelet
</span></span></code></pre></div><p>Iniciamos el Cluster kubeadm</p>
<h3 id="creacion-de-cluster-con-kubeadm">Creacion de cluster con Kubeadm</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>kubeadm init --apiserver-advertise-address 192.168.0.54 --pod-network-cidr 10.10.10.0/24
</span></span></code></pre></div><p>Una vez haya finalizado nos quedará un <strong>token</strong> que debemos guardar y unos comandos a lanzar desde el usuario del que vamos a usar kubernetes para instalar los <strong>certificados</strong>.</p>
<p><img alt="esquema" src="/images/kubernetes/preparacion/3.png"></p>
<p>Nos dejara el siguiente mensaje. Es <strong>importante</strong> que guardemos los <strong>tokens</strong> proporcionados y ejecutemos los comandos según sea conveniente para poder comunicarnos con la API.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>To start using your cluster, you need to run the following as a regular user:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mkdir -p $HOME/.kube
</span></span><span style="display:flex;"><span>  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
</span></span><span style="display:flex;"><span>  sudo chown $(id -u):$(id -g) $HOME/.kube/config
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Alternatively, if you are the root user, you can run:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  export KUBECONFIG=/etc/kubernetes/admin.conf
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>You should now deploy a pod network to the cluster.
</span></span><span style="display:flex;"><span>Run &#34;kubectl apply -f [podnetwork].yaml&#34; with one of the options listed at:
</span></span><span style="display:flex;"><span>  https://kubernetes.io/docs/concepts/cluster-administration/addons/
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Then you can join any number of worker nodes by running the following on each as root:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>kubeadm join 192.168.0.54:6443 \
</span></span><span style="display:flex;"><span>    --token kl5i5b.ziwjtglhh958y2pc --discovery-token-ca-cert-hash sha256:9e632f0e0ff18d271d1ee43e8b135ede-xxxxxxxxxxxxxxxxxxxxxxx
</span></span></code></pre></div><h2 id="container-network-interface-cni">Container Network Interface (CNI)</h2>
<p>Kubernetes necesitará una serie de <strong>pluggins</strong> básicos para preparar la interfaz de red entre los contenedores.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git clone https://github.com/containernetworking/plugins
</span></span><span style="display:flex;"><span>cd plugins
</span></span><span style="display:flex;"><span>git checkout v1.1.1
</span></span><span style="display:flex;"><span>./build_linux.sh
</span></span><span style="display:flex;"><span>sudo mkdir -p /opt/cni/bin
</span></span><span style="display:flex;"><span>sudo cp bin/* /opt/cni/bin/
</span></span></code></pre></div><h2 id="cni---calico">CNI - CALICO</h2>
<p><strong>Calico</strong> es una solución de red y seguridad Open-Source para Kubernetes es capaz de comunicar la red entre los contenedores basándose en los pluggins por defecto.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>kubectl apply -f https://docs.tigera.io/calico/latest/manifests/calico.yaml
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.31.2/manifests/tigera-operator.yaml
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.31.2/manifests/custom-resources.yaml
</span></span></code></pre></div><p>Comprobaremos que esta funcionando con el siguiente comando:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>watch kubectl get tigerastatus
</span></span></code></pre></div><p><img alt="esquema" src="/images/kubernetes/preparacion/4.png"></p>
<h3 id="untaint-nodes">Untaint Nodes</h3>
<p>Una vez el cluster se haya iniciado los nodos que tengamos “repelerán” la asignación de pods por defecto, esto ayuda a la gestión de recursos y a que en el nodo que actue como Control Plane (CP) no tenga carga de trabajo extra. En nuestro caso utilizaremos tres nodos incluyendo el CP por lo que eliminaremos este ‘Taint’.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>kubectl taint nodes --all node-role.kubernetes.io/control-plane- 
</span></span></code></pre></div><p>Tendremos el cluster de la siguiente manera. Se podrán observar los pods de <strong>Calico, almacenamiento (etcd), DNS, Api-server, proxy y scheduler</strong>.
Estos pods son la estructura base de nuestro cluster y han de estar siempre en estado &ldquo;Running&rdquo;.
<img alt="esquema" src="/images/kubernetes/preparacion/5.png"></p>
<p>Procedemos a unir un nodo trabajador mediante el comando que nos ha mostrado el nodo <strong>master</strong>. Veremos como aparecen nuevos <strong>pods</strong> relacionados con <strong>Calico</strong> y con <strong>Proxy</strong>.
Se pondrán en estado &ldquo;Running&rdquo; y eso significará que el nodo se ha unido correctamente al cluster.
<img alt="esquema" src="/images/kubernetes/preparacion/6.png"></p>
<p>De la misma manera uniremos el segundo y LISTO!</p>
<h1 id="conclusion">Conclusion</h1>
<p>Estos son los primeros pasos de un cluster Kubeadm en local. Podremos observar como el entorno se realiza con el runtime de <strong>ContainerD</strong> (El entorno de virtualización de Docker).
Partiendo de estas bases podremos crear <strong>Despliegues, contenedores con nuestras aplicaciones, bases de datos</strong> etc. Todo este entorno se controlará a traves de archivos <strong>YAML</strong> y comandos con
la herramienta <strong>kubectl</strong> desde la consola. Es importante controlar bien los <strong>certificados</strong> y <strong>permisos (RBAC)</strong> para una gestion segura y eficiente del entorno. Una vez tengamos el entorno preparado podremos empezar
a aprender a cerca de la gestión de sus recuros. Kubernetes(k8s) es una herramienta muy potente en los entornos de produccion de <strong>desarrollo, capaz de automatizar, implementar y escalar</strong> servicios gestionados en <strong>contenedores</strong>.</p>
]]></content></item><item><title>Autopsy</title><link>https://kerneloop.github.io/posts/autopsy/</link><pubDate>Mon, 22 Dec 2025 13:28:55 +0100</pubDate><guid>https://kerneloop.github.io/posts/autopsy/</guid><description>Forensic Analisys Como analistas forenses se nos presenta una imagen obtenida del equipo personal de un crimen digital. Nuestra tarea es analizar esta imagen de su equipo y sacar las conclusiones que se convertirán en Evidencias Digitales para su posterior presentación.
REQUISITOS Sistema Operativo -&amp;gt; Windows 10
Software -&amp;gt; FTK Imager - Autopsy
PROCEDIMIENTO FTK Imager Para comenzar con este analisis lo primero es hacer una imagen del equipo, para ello utilizaremos FTK Imager.</description><content type="html"><![CDATA[<h1 id="forensic-analisys">Forensic Analisys</h1>
<p><img alt="esquema" src="/images/Autopsy/perro.png">
Como analistas forenses se nos presenta una imagen obtenida del equipo personal de un crimen digital. Nuestra tarea es analizar esta imagen de su equipo y sacar las conclusiones que se convertirán en Evidencias Digitales para su posterior presentación.</p>
<h2 id="requisitos">REQUISITOS</h2>
<p>Sistema Operativo -&gt; Windows 10<br>
Software -&gt; FTK Imager - Autopsy</p>
<h1 id="procedimiento">PROCEDIMIENTO</h1>
<h2 id="ftk-imager">FTK Imager</h2>
<p>Para comenzar con este analisis lo primero es hacer una <strong>imagen del equipo</strong>, para ello utilizaremos FTK Imager. Lo iniciaremos y haremos click en Create Disk Image desde el menu. Nota: El disco duro ha de estar insertado.<br>
<img alt="esquema" src="/images/Autopsy/FTK/1.png"><br>
Se presentará una nueva ventana con las multiples opciones de copiado Elegiremos la <strong>Fisica</strong>.<br>
<img alt="esquema" src="/images/Autopsy/FTK/2.png"><br>
Seleccionaremos el disco duro que vamos a copiar y haremos click en “<em>Siguiente</em>”.<br>
<img alt="esquema" src="/images/Autopsy/FTK/3.png"><br>
En la creacion de imagen le daremos a <strong>Add</strong> para añadir un destino de la imagen.<br>
<img alt="esquema" src="/images/Autopsy/FTK/4.png"><br>
Seleccionaremos el tipo de copiado, en nuestro caso <strong>DD</strong> (Data duplicator) ya que va recorriendo a un <strong>nivel más bajo</strong> los sectores del disco y por ende la copia es de mayor calidad.<br>
<img alt="esquema" src="/images/Autopsy/FTK/5.png"><br>
Rellenaremos los datos necesarios para detallar el caso en la siguiente ficha.<br>
<img alt="esquema" src="/images/Autopsy/FTK/6.png"><br>
Y por ultimo añadiremos el destino de la copia e indicaremos su nombre. Podemos personalizar también el tamaño de los fragmentos.<br>
<img alt="esquema" src="/images/Autopsy/FTK/7.png"><br>
Una vez haya terminado el proceso se presentará la siguiente ventana. Desde la que podremos ver su <strong>código Hash</strong> asignado y calculado con las funciones <strong>MD5 y SHA1</strong>. También veremos sus propiedades como numero de sectores y si hay algún bloque corrupto en el disco.<br>
Es muy importante apuntar el Código Hash ya que aquí comienza la <strong>Cadena de Custodia</strong> de este elemento, siendo identificado en todo momento y comprobando su integridad con esta cadena de caracteres.<br>
<img alt="esquema" src="/images/Autopsy/Fincopiadohash.png"><br>
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
<img alt="esquema" src="/images/Autopsy/Fincopianohash.png"><br>
Por ultimo podemos obtener un resumen en formato texto de esta tarea:<br>
Nos proporcionará información extra muy útil en nuestra tarea como forenses.<br>
<img alt="esquema" src="/images/Autopsy/Summary.png"></p>
<h2 id="autopsy">Autopsy</h2>
<p>Comenzaremos abriendo la herramienta. Se nos solicitará información y datos para crear un nuevo caso de investigación forense. Haremos click en “New Case”.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/0.png"><br>
Aquí personalizaremos y añadiremos la ruta de almacenamiento del caso que hemos creado y daremos algunos detalles del caso que vamos a analizar:<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/1.png"><br>
Tras hacer click en Next completamos la información restante con los <strong>máximos detalles</strong> posibles y le damos a &ldquo;Finish&rdquo;.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/2.png"><br>
Añadiremos como origen de datos la copia virtual del disco desde <strong>“Add Datasource”</strong>. Rellenaremos los datos según nuestra conveniencia. Por el momento el Host lo mantendremos por defecto.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/3.png"><br>
Como data source type elegiremos <strong>“Disk Image or VM file”</strong> que sera el correspondiente a la copia que hemos realizado.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/4.png"><br>
Buscaremos la ruta de la copia que hemos realizado y seleccionaremos el primer elemento de la copia.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/5.png"><br>
Nota: Puede variar según el tipo de copia que hayamos realizado (DD Raw SMART E01 etc)<br>
Si lo deseamos para aumentar el nivel de integridad podemos añadir los resultados de las <strong>funciones Hash</strong> calculadas previamente.<br>
Haremos click en next y veremos una nueva ventana en la que se presentan todos los módulos con los que podemos trabajar desde autopsy. Deseleccionaremos todos y marcaremos <strong>“Recent Activity”</strong> para reducir el tiempo de análisis.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/6.png"><br>
Iniciaremos el proceso de extracción de datos y esperaremos a los resultados.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/7.png"><br>
<img alt="esquema" src="/images/Autopsy/Autopsy/8.png"><br>
Vemos que ha finalizado sin problemas y procederemos al <em>análisis en profundidad</em>.<br>
Se presentará una interfaz en la que se podrá identificar de manera visual todos los datos extraidos de la imagen de disco proporcionada:<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/9.png"><br>
Iremos poco a poco desmenuzando la información obtenida.<br>
Primero se proporcionará la <em>estructura global</em> de datos del disco, pudiendo ver <em>particiones, estructuras de carpetas y datos detallados</em> del sistema de archivos:<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/10.png"><br>
Podremos ver los detalles en <strong>“Data Artifacts”</strong> . <em>Sistema Operativo, nombre del equipo, nombre del propietario, etiqueta del disco</em> etc.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/11.png"><br>
Desde “File views” observaremos una clasificacion de archivos por extensiones desde la que podremos sacar <strong>imagenes, videos, bases de datos, documentos HTML o de texto plano etc</strong>.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/12.png"><br>
De esta sección queda a destacar la gran cantidad de imágenes que existen (las cuales incluyen iconos e imágenes del sistema) y la cantidad de documentos HTML lo cual nos hace pensar que hosteaba algún tipo de <em>servidor</em>.<br>
Si investigamos más a fondo en los documentos HTML veremos nombres <em>git</em> lo que nos hace pensar que tiene relacion con el software <strong>“Git”</strong> o hostea este tipo de estructuras.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/13.png"><br>
Más adelante tenemos una seccion muy interesante llamada <strong>“Deleted Files”</strong> la cual llama la atencion investigar, teniendo en cuenta que se le haya podido escapar algún documento eliminado que no ha borrado correctamente. Cambien incluye documentación temporal o de inicio del equipo.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/14.png"><br>
Pasamos a una sección muy interesante, <strong>“MB File Size”</strong>. Aqui se dividen los archivos por tamaño, pudiendo clasificarse en:</p>
<ul>
<li><strong>MB 50 – 200</strong> → Archivos pequeños como configuraciones o documentos personales de texto o trabajos particulares. Muy interesantes para investigar configuraciones personalizadas o documentos con información más personal. También ejecutables o accesos directos.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/15.png"></li>
<li><strong>MB 200 – 1GB</strong> → Este rango incluirá desde documentos pesados como librerias contundentes hasta programas instalados en el equipo.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/16.png"></li>
<li>**MB 1GB+ **→ Estos documentos tan pesados son posibles bases de datos del sistema, como hemos visto previamente en el apartado de archivos HTML, aquí aparecerán los archivos de las BBDD de la web. También aparecerán almacenamientos de paginación de programas grandes en los que la memoria RAM se saturaba.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/17.png"><br>
Pasamos a la seccion <strong>“Data Artifacts”</strong>. Aqí se clasificarán los datos obtenidos en diferentes grupos:<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/18.png"><br>
Destacaremos <em>Programas instalados, Documentos Recientes, Programas corriendo, USB Device Attached, Web Accounts, Coockies, Downloads e Historial y por ultimo Web Form Autofill</em>.</li>
<li><strong>Programas Instalados</strong>. Una seccion que nos indicará el tipo de trabajo que realizaba el usuario y las tareas que desempeñaba. Podemos ver SOFTWARE como HomeBank o Money Manager que nos indica el manejo de cuentas bancarias.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/19.png"></li>
<li><strong>Documentos Recientes</strong>. Una seccion util, mostrará su actividad reciente. Podemos observar que trabajaba con archivos de Github, corroborando lo visto previamente en HTML Docs.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/20.png"></li>
<li><strong>Programas Corriendo</strong>. Aqui veremos los programas que estaban iniciados en el sistema cuando se tomó la imagen, se mostrarán los servicios de los que se disponia como Git o GithubDesktop.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/21.png"><br>
También aparece Chrome.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/22.png"></li>
<li><strong>USB Device Attached</strong>. Veremos los dispositivos USB externos con los que trabajaba, es interesante de cara a la información no contenida en el equipo y posiblemente relacionada con el escenario. Veremos sus ID’s e información de los dispositivos para comprara con los que se han encontrado en la escena.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/23.png"></li>
<li><strong>Web Accounts, Cookies e Historial</strong>. Aqui podremos ver los diversos datos de navegación del usuario, como las paginas en las que se ha registrado y su nombre de usuario o correo (<a href="mailto:bart.simpson_springfield@hotmail.com">bart.simpson_springfield@hotmail.com</a>) (Github)<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/24.png"><br>
Tambien veremos las cookies, pudiendo dar pistas sobre que webs se ha navegado<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/25.png"><br>
Y el historial que indica el proceso de navegación. (Principalmente Github)<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/26.png"></li>
<li>Por ultimo tenemos la sección <strong>Web Form Autofill</strong>. Que mostrará la información guardada en el navegador para auto rellenar los formularios, esta es información muy sensible, ya que implica datos personales del usuario. Puede ser útil de cara a una investigación pero ha de ser manejada con cuidado.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/27.png"><br>
En el apartado de  <em>“Analisys Results”</em> tenemos Web Account type, desde donde podremos obtener tambien información muy valiosa, como las <strong>preguntas de seguridad</strong> del usuario Bart:<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/28.png"><br>
Queda a destacar que según vamos haciendo el proceso de investigación podremos marcar con <strong>“Tags”</strong> los artefactos que nos sugieran infomación interesante. Estos se reflejarán en la ultima seccion Tags. Un ejemplo:<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/29.png"><br>
<img alt="esquema" src="/images/Autopsy/Autopsy/30.png"></li>
</ul>
<h2 id="report">Report</h2>
<p>Generaremos un reporte para poder ver los datos mas claramente desde <strong>“Generate Report”</strong>.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/31.png"><br>
Usaremos el formato <strong>HTML</strong>.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/32.png"><br>
Seleccionamos el <strong>Data source</strong>.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/33.png"><br>
Y todos los resultados especificados, en nuestro caso las marcas<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/34.png"><br>
Esperaremos a la generacion<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/35.png"><br>
Una vez generado lo abriremos en nuestro navegador para su mejor visualización.<br>
<img alt="esquema" src="/images/Autopsy/Autopsy/36.png"></p>
<h3 id="incidencias">INCIDENCIAS.</h3>
<p>Sin Incidencias notificadas.</p>
<h3 id="bibliografía">BIBLIOGRAFÍA.</h3>
<ul>
<li><a href="https://www.autopsy.com/">https://www.autopsy.com/</a></li>
</ul>
]]></content></item><item><title>LanTap</title><link>https://kerneloop.github.io/posts/lantap/</link><pubDate>Mon, 18 Aug 2025 21:21:43 +0200</pubDate><guid>https://kerneloop.github.io/posts/lantap/</guid><description>En este ejercicio vamos a preparar un intermediario en una red, a traves de este intermediario seremos capaces de interceptar todo el trafico que pase por el nodo de conexion. Este tipo de prácticas son útiles a la hora de capturar y monitorizar de una manera precisa todo el trafico. Tambien es conocido como un método de ataque invasivo conocido como &amp;ldquo;Sniffing - Lan Tap&amp;rdquo; en el que un atacante recogerá y almacenará los paquetes que reciba y envie la victima para su posterior analisis.</description><content type="html"><![CDATA[<p>En este ejercicio vamos a preparar un intermediario en una red, a traves de este intermediario seremos capaces de <em><strong>interceptar</strong></em> todo el <em><strong>trafico</strong></em> que pase por el nodo de conexion. Este tipo de prácticas son útiles
a la hora de capturar y monitorizar de una manera precisa todo el trafico. Tambien es conocido como un método de ataque invasivo conocido como &ldquo;Sniffing - Lan Tap&rdquo; en el que un <em><strong>atacante</strong></em> recogerá y almacenará
los paquetes que reciba y envie la victima para su posterior analisis. A traves de este método un atacante puede obtener de manera <em><strong>ilegitima</strong></em> <em><strong>contraseñas</strong></em>, nombres de <em><strong>usuario</strong></em> e información <em><strong>sensible</strong></em> de un usuario.</p>
<h2 id="esquema">Esquema</h2>
<p>Partiremos del esquema con el que vamos a trabajar:
<img alt="esquema" src="/images/LanTap/Schema.png"></p>
<p>Podemos observar que el momento de intercepción de datos se encuentra entre el <em><strong>firewall</strong></em> y el resto de equipos conectados al <em><strong>switch</strong></em>. De esta manera podremos interceptar tod el trafico que fluya hacia los
equipos que se encuentran dentro de la <em><strong>red</strong></em>.</p>
<h2 id="preparacion">Preparacion</h2>
<p>Procederemos a cortar el cable de <em><strong>conexion</strong></em> entre el <em><strong>router</strong></em> y el <em><strong>switch</strong></em>, lo pelaremos con una herramienta de crimpado y separaremos los cables que se encuentran en el interior del <em><strong>RJ-45</strong></em>.
Siguiendo esta tabla podremos ver el codigo de colores de un cable de conexion RJ-45 estandart.</p>
<p><em><strong>OJO</strong></em> -&gt; No confundir con cable de conexion <em><strong>CRUZADO</strong></em>, tiene otro tipo de orden de colores y usos.<br>
<img alt="esquema" src="/images/LanTap/colortable.png"></p>
<p>Pelaremos los cables y los volveremos a conectar, de manera que el cobre de las conexiones <em><strong>NARANJA</strong></em>, <em><strong>NARANJA-BLANCO</strong></em>, <em><strong>VERDE</strong></em> y <em><strong>VERDE-BLANCO</strong></em> queden expuestos al contacto fisico.<br>
<img alt="esquema" src="/images/LanTap/wires.png"></p>
<p>Pelaremos otros dos cables <em><strong>RJ-45</strong></em> de la siguiente manera:</p>
<h3 id="cable-1">Cable 1</h3>
<ul>
<li>Extremo 1 -&gt; Clavija estandart <em><strong>RJ-45</strong></em>.</li>
<li>Extremo 2 -&gt; Conexion NARANJA y NARANJA-BLANCO expuesto.</li>
</ul>
<h3 id="cable-2">Cable 2</h3>
<ul>
<li>Extremo 1 -&gt; Clavija estandart <em><strong>RJ-45</strong></em>.</li>
<li>Extremo 2 -&gt; Conexion VERDE y VERDE-BLANCO expuesto.</li>
</ul>
<p>De esta manera uniremos las conexiones de <em><strong>Cable 1</strong></em> a los polos naranjas del cable de conexion entre el router y el switch y el <em><strong>Cable 2</strong></em> a los polos verdes del mismo.</p>
<p><img alt="esquema" src="/images/LanTap/howitwork.png"></p>
<p>Necesitaremos dos adaptadores de RJ-45 a <em><strong>USB</strong></em> para conectarlos al equipo que va a monitorear el trafico, los conectaremos respectivamente e iniciaremos la aplicacion Wireshark previamente instalada.</p>
<p>Veremos que aparecerán los dos adaptadores en el inicio de <em><strong>Wireshark</strong></em>, los seleccionaremos manteniendo pulsada la tecla CRTL e iniciaremos la monitorización.</p>
<p><img alt="esquema" src="/images/LanTap/twoadapters.png"></p>
<h2 id="monitorización">Monitorización</h2>
<p>Una vez hayamos iniciado el rastreo de paquetes podremos ver como aparecen en pantalla todos los <em><strong>paquetes</strong></em> que pasan a traves de la conexion entre el router y el switch hacia la red que hemos preparado.
Se ve indicado el <em><strong>origen</strong></em> y <em><strong>destino</strong></em> de cada paquete junto a su fecha de envio, <em><strong>protocolo</strong></em>, longitud e información.
<img alt="esquema" src="/images/LanTap/result.png"></p>
<p>Una vez lo deseemos, podremos finalizar la captura de paquetes para poder analizar más en detalle el <em><strong>trafico</strong></em> <em><strong>interceptado</strong></em> y analizar algun tipo de trafico sospechoso, indeseado o de dudosa procedencia.
Este archivo con la captura se podrá guardar en formato <em><strong>.pcapng</strong></em> para su posterior manejo.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Este método de análisis es muy interesante por parte de un <em><strong>atacante</strong></em> para interceptar el tráfico que se mueve en una red a la que se tiene acceso físico, es una metodología <em><strong>silenciosa</strong></em>,
no genera ningún tipo de <em><strong>registro</strong></em> y si esta bien preparada es <em><strong>imperceptible</strong></em> a ojos de un usuario común. Es un riesgo que algunas empresas/entornos han llegado a enfrentar en diversas situaciones,
por eso la <em><strong>seguridad</strong></em> <em><strong>fisica</strong></em> es tan <em><strong>crucial</strong></em> como la seguridad a nivel de software.</p>
]]></content></item><item><title>Data Diode</title><link>https://kerneloop.github.io/posts/datadiode/</link><pubDate>Mon, 18 Aug 2025 20:47:16 +0200</pubDate><guid>https://kerneloop.github.io/posts/datadiode/</guid><description>En este proyecto veremos lo que es un diodo de datos. Como bien indica en su nombre se trata de un conducto de informacion en un unico sentido. El objetivo será que el agente que envie informacion no sea capaz de recibirla, de manera que el sistema crítico se encontrará completamente aislado de comunicaciones externas y será capaz de transmitir información para su monitorización, registro y gestión.
Para empezar debemos entender que protocolos de comunicación vamos a utilizar en este ejercicio.</description><content type="html"><![CDATA[<p>En este proyecto veremos lo que es un <strong>diodo de datos</strong>. Como bien indica en su nombre se trata de un conducto de informacion en un unico sentido.
El objetivo será que el agente que envie informacion no sea capaz de recibirla, de manera que el sistema crítico se encontrará completamente aislado de comunicaciones
externas y será capaz de transmitir información para su monitorización, registro y gestión.</p>
<p>Para empezar debemos entender que protocolos de comunicación vamos a utilizar en este ejercicio.</p>
<p><img alt="Architecture1" src="/images/DataDiode/tcpudpblack.jpg"></p>
<h3 id="tcp">TCP</h3>
<p>El protocolo TCP (Transmission Control Protocol) es un protocolo fundamental en la comunicación de datos a través de redes informáticas garantizando una transmisión confiable y ordenada de la información entre dispositivos.
Tiene un funcionamiento que se divide principalmente en <strong>tres partes:</strong></p>
<ul>
<li><strong>SYN</strong> -&gt; El cliente inicia la conexión enviando un paquete SYN al servidor. Este paquete contiene un número de secuencia aleatorio que se utilizará para identificar los paquetes enviados por el cliente.</li>
<li><strong>SYN ACK</strong> -&gt; El servidor, al recibir el SYN, responde con un paquete SYN-ACK. Este paquete incluye el número de secuencia del cliente incrementado en uno y un nuevo número de secuencia para la comunicación del servidor al cliente.</li>
<li><strong>ACK</strong> -&gt; El cliente recibe el SYN-ACK y envía un último paquete ACK al servidor, confirmando la conexión y utilizando el número de secuencia del servidor incrementado en uno.</li>
</ul>
<p>Como podemos ver, en esta comunicacion se requiere contacto entre los dos agentes, tanto como para iniciar la conexion como para finalizarla.</p>
<h3 id="udp">UDP</h3>
<p>El protocolo UDP (User Datagram Protocol) es un protocolo de red que permite el envío de datos sin necesidad de establecer una conexión previa entre emisor y receptor, a diferencia de TCP.
Esto significa que <strong>UDP</strong> envía datagramas (paquetes de datos) de forma independiente y no garantiza la recepción, el orden ni la integridad de los datos. Su principal ventaja es la velocidad y eficiencia, ideal para aplicaciones donde la latencia es crítica, como streaming de video o juegos online.</p>
<p><strong>Funcionamiento:</strong></p>
<ul>
<li><strong>UDP</strong> divide los datos en paquetes (datagramas) y los envía a la dirección IP y puerto de destino, sin establecer una conexión formal.</li>
<li>No hay establecimiento de conexión previo ni confirmación de recepción, lo que permite una comunicación rápida.</li>
<li><strong>UDP</strong> no garantiza que los datagramas lleguen a destino, ni que lleguen en el orden correcto o sin errores.</li>
</ul>
<h2 id="entornos-de-uso">Entornos de uso</h2>
<p>Este tipo de dispositivos se situan en entornos críticos como Plantas Industriales/Nucleares, laboratorios de ciberseguridad o zonas de máxima seguridad.<br>
Gracias a esta metodología seremos capaces de monitorizar desde un SOC exterior todo el entorno al otro lado del Diodo, pudiendo registrar y recibir lecturas
de temperatura en centrales industriales o evitando que un virus informático logre una conexion externa con un atacante mientras se hacen pruebas.</p>
<p><img alt="Architecture2" src="/images/DataDiode/datadiodetap.webp"></p>
<h2 id="equipo-y-montaje">Equipo y Montaje</h2>
<p>Actualmente existen varios proveedores de dispositivos que realizan esta funcion y esta implementada directamente en el hardware que distribuyen.<br>
Nosotros utilizaremos una solucion más económica y casera a traves de convertidores de Fibra Óptica a Cobre. Es importante que estos convertidores dispongan de dos
entradas (Rx) y salidas (Tx) ya que en esa division nos permitirá separar el tráfico para hacer el diodo.</p>
<p><img alt="Convertidores" src="/images/DataDiode/Convertidor.jpg"></p>
<p>Una vez tengamos estos dispositivos procederemos a conectar la fibra y el cobre de la siguiente manera:<br>
<img alt="Architecture3" src="/images/DataDiode/architecture.png"></p>
<h3 id="funcionamiento">Funcionamiento</h3>
<p>Veremos que el equipo que envía se conecta directamente al equipo que recibe a traves de Tx y Rx sin embargo
hay un convertidor de fibra a cobre entre los dos equipos que no tiene salida de cobre, este será el &ldquo;vacio&rdquo;.
El equipo receptor intentará dar una respuesta, comprobará que la puede enviar, y la enviará a este &ldquo;vacio&rdquo; a través de Tx a Rx pero no será recibida por ningun equipo.<br>
Este engaño se produce tambien para el equipo que envia ya que realizará una comprobacion en Rx para ver si puede recibir informacion en la red preparada, al estar conectado el cable
de fibra interpretará que la conexion es correcta pero nunca recibirá nada ya que viene de el convertidor &ldquo;vacio&rdquo;.</p>
<p><strong>¡IMPORTANTE!</strong><br>
Los dos equipos no disponen de ningun servidor DHCP ni de ninguna figura intermediaria que sea capaz de redireccionar el trafico en la conexion.
Deberemos de preparar una direccion IP para cada uno y añadir en las tablas ARP las direcciones MAC de los dos equipos.<br>
Utilizaremos el siguiente comando en una consola con permisos de administrador:</p>
<pre tabindex="0"><code class="language-CMD/POWERSHELL" data-lang="CMD/POWERSHELL">arp -s {direccion IP} {direccion mac}
</code></pre><p>Para comprobar que se ha añadido correctamente usaremos <strong>arp -a</strong>.</p>
<h2 id="puesta-en-marcha">Puesta en marcha</h2>
<p>Utilizaremos un rastreador de paquetes en el equipo que recibe de manera que cuando establezcamos una conexion TCP podramos ver la recepcion del paquete y un envio fallido de respuesta, por el contrario
en una conexion UDP podremos ver la recepcion del paquete y ninguna respuesta.</p>
<p>Existen multiples herramientas para rastrear esta conexion como <em><strong>tcpdump</strong></em> que funciona a nivel de consola o <em><strong>wireshark</strong></em> que posee una interfaz más amigable.</p>
<p>En este caso utilizaremos <em><strong>wireshark</strong></em> y lo prepararemos en la máquina receptora escuchando en la interfaz en la que estén conectados los equipos.</p>
<p>Ahora desde &ldquo;CMD&rdquo; enviaremos el comando de ping desde la maquina que envia a la que recibe, podremos ver como aparecen los mensajes en la interfaz, su origen y direccion.</p>
<p><img alt="Ping" src="/images/DataDiode/ping.png"></p>
<p>Podremos ver como la maquina receptora intenta devolver el ping, sin embargo en el equipo que inicia la conexion no estamos recibiendo respuesta.</p>
<p><img alt="Pingmal" src="/images/DataDiode/pingmal.png"></p>
<p>En cuanto a la conexion UDP enviaremos un mensaje al receptor con el la herramienta netcat y el comando <em><strong>nc64.exe</strong></em> <em><strong>-u</strong></em> <em><strong>192.168.2.12</strong></em> <em><strong>1234</strong></em>. Desde el lado del receptor estaremos escuchando en wireshark y abriremos una consola
de comandos &ldquo;CMD&rdquo; y escribiremos el siguiente comando <em><strong>nc64.exe</strong></em> <em><strong>-ulvp</strong></em> <em><strong>1234</strong></em>.</p>
<p>Una vez establecida esta conexion procederemos a escribir cualquier caracter en la consola del equipo que envia, podremos ver como aparece en la consola del que recibe. Desde <em><strong>wireshark</strong></em> se verá como llega el paquete con
su longitud y protocolo UDP.</p>
<p>Consola:
<img alt="UDPLetra" src="/images/DataDiode/udpletra.png"></p>
<p>Wireshark:
<img alt="UDP" src="/images/DataDiode/udp.png"></p>
<p>El flujo de los datos de este procedimiento será de la siguiente manera.</p>
<p><img alt="Architecture4" src="/images/DataDiode/architecturediode.png"></p>
<h2 id="conclusion">Conclusion</h2>
<p>Este tipo de tecnologías se utilizan en entornos muy críticos, es imprescindible conocer el funcionamiento de las conexiones <em><strong>TCP</strong></em> y <em><strong>UDP</strong></em> que se van a utilizar para poder comprender el flujo de los datos.<br>
De esta manera aseguramos un sistema en el que podremos recibir o enviar informacion exclusivamente en un sentido. A diferencia de un firewall que se regula por las reglas establecidas por el administrador de sistemas en cuestion,
este metodo asegura una imposibilidad de flujo más que <em><strong>logica</strong></em> &hellip;. <em><strong>ES</strong></em> <em><strong>FISICA!!</strong></em> El acceso a el sistema por la parte bloqueada del diodo esta restringida sin acceso fisico a la instalacion, lo cual da un <em><strong>grado</strong></em> <em><strong>de</strong></em> <em><strong>seguridad</strong></em> <em><strong>dificilmente</strong></em>
<em><strong>evadible</strong></em>.</p>
]]></content></item><item><title>ThunderDB</title><link>https://kerneloop.github.io/posts/thuderdb/</link><pubDate>Sun, 29 Jun 2025 20:45:04 +0200</pubDate><guid>https://kerneloop.github.io/posts/thuderdb/</guid><description>Introduccion En este proyecto realizaremos un manejo de parametros de los rayos y truenos de la página web Blitzortung a traves de un web socket.
Lo primero es acceder a la web, para ver el websocket que utilizaremos. Presionando la tecla abriremos el panel de desarrollador y nos dirigiremos al apartado &amp;ldquo;Network&amp;rdquo; &amp;ldquo;Socket&amp;rdquo;.
Desde aquí podremos identificar en la seccion &amp;ldquo;Name&amp;rdquo; el websocket que vamos a utilizar.
WEB SOCKET-&amp;gt; &amp;ldquo;wss://ws1.blitzortung.org/&amp;rdquo;.</description><content type="html"><![CDATA[<h3 id="introduccion">Introduccion</h3>
<p>En este proyecto realizaremos un manejo de parametros de los <strong>rayos</strong> y <strong>truenos</strong> de la página web <a href="https://www.blitzortung.org">Blitzortung</a>
a traves de un <em>web socket</em>.<br>
Lo primero es acceder a la web, para ver el websocket que utilizaremos. Presionando la tecla <!-- raw HTML omitted --> abriremos el panel de desarrollador y nos dirigiremos al apartado &ldquo;Network&rdquo; &ldquo;Socket&rdquo;.</p>
<p><img alt="Socket" src="/images/ThunderDB/socket.png"></p>
<p>Desde aquí podremos identificar en la seccion &ldquo;Name&rdquo; el websocket que vamos a utilizar.<br>
<strong>WEB SOCKET</strong>-&gt; &ldquo;wss://ws1.blitzortung.org/&rdquo;.<br>
Veremos que esta constantemente recibiendo informacion, sin embargo podremos ver que está cifrada.</p>
<p>Investigando la forma de trabajo del websocket identificaremos el metodo que utiliza para iniciar la conexion.
Como requisito necesitará que le pasemos en formato JSON el contenido {&ldquo;a&rdquo;:111}.<br>
Una vez se ha realizado comenzará a enviar todos los eventos.<br>
Bien, con un poco de codigo simple relacionado con Web-Sockets seremos capaces de recibir esta informacion. Ahora el problema es que esta obfuscada.<br>
Buscando un poco por internet y analizando el formato podremos descubrir que se trata de obfuscacion LZW.</p>
<p>Procederemos a generar un codigo de python que maneje toda la informacion y sea capaz de deobfuscar los datos que recibimos para su tratamiento.</p>
<p>Utilizaremos las librerias <strong>websocket y json</strong>.</p>
<p><strong>La funcion de deobfuscamiento será la siguiente:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decoder</span>(encoded_str):
</span></span><span style="display:flex;"><span>    e <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>    d <span style="color:#f92672">=</span> list(encoded_str)
</span></span><span style="display:flex;"><span>    c <span style="color:#f92672">=</span> d[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>    f <span style="color:#f92672">=</span> c
</span></span><span style="display:flex;"><span>    g <span style="color:#f92672">=</span> [c]
</span></span><span style="display:flex;"><span>    h <span style="color:#f92672">=</span> <span style="color:#ae81ff">256</span>
</span></span><span style="display:flex;"><span>    o <span style="color:#f92672">=</span> h
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(d)):
</span></span><span style="display:flex;"><span>        a <span style="color:#f92672">=</span> ord(d[i])
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> a <span style="color:#f92672">&lt;</span> h:
</span></span><span style="display:flex;"><span>            a_str <span style="color:#f92672">=</span> d[i]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> a <span style="color:#f92672">in</span> e:
</span></span><span style="display:flex;"><span>            a_str <span style="color:#f92672">=</span> e[a]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            a_str <span style="color:#f92672">=</span> f <span style="color:#f92672">+</span> c
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        g<span style="color:#f92672">.</span>append(a_str)
</span></span><span style="display:flex;"><span>        c <span style="color:#f92672">=</span> a_str[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>        e[o] <span style="color:#f92672">=</span> f <span style="color:#f92672">+</span> c
</span></span><span style="display:flex;"><span>        o <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        f <span style="color:#f92672">=</span> a_str
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join(g)<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#39;latin1&#39;</span>)
</span></span></code></pre></div><p>Nuestro codigo ha de tener una funcion para mostrar la información de una manera visible, así comprobaremos que estamos tratando con los datos correctos.<br>
Para ello mostraremos tanto el codigo obfuscado y el deobfuscado.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">on_message</span>(ws, message):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Mensaje recibido (texto):&#34;</span>, message[:<span style="color:#ae81ff">100</span>], <span style="color:#e6db74">&#34;...&#34;</span>)  <span style="color:#75715e"># Mostrar un resumen</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Aplicar LZW decoder al mensaje completo (texto plano recibido)</span>
</span></span><span style="display:flex;"><span>    decoded_bytes <span style="color:#f92672">=</span> decoder(message)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>        decoded_text <span style="color:#f92672">=</span> decoded_bytes<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;utf-8&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">UnicodeDecodeError</span>:
</span></span><span style="display:flex;"><span>        decoded_text <span style="color:#f92672">=</span> decoded_bytes<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;latin1&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Texto decodificado:&#34;</span>, decoded_text[:<span style="color:#ae81ff">200</span>], <span style="color:#e6db74">&#34;...&#34;</span>)  <span style="color:#75715e"># Mostrar un resumen</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>        data <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>loads(decoded_text)
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Datos JSON parseados correctamente:&#34;</span>, data)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">except</span> json<span style="color:#f92672">.</span>JSONDecodeError:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;No se pudo parsear JSON después de decodificar&#34;</span>)
</span></span></code></pre></div><p>Una vez seamos capaces de obtener los datos decodificados podremos empezar a trabajar con ellos!
Creando dos contenedores de <strong>Docker</strong> (Mysql y Grafana) le daremos forma y vida a estos datos obtenidos.</p>
<h3 id="mysql">MySQL</h3>
<ul>
<li>sudo docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=&lt;CONTRASEÑA&gt; &ndash;name=mysql mysql</li>
</ul>
<h3 id="grafana">Grafana</h3>
<ul>
<li>sudo docker run -d -p 3000:3000 &ndash;name=grafana grafana/grafana-enterprise</li>
</ul>
<p>Partiremos de una instalacion predefinida con usuario admin en MySQL y una configuracion por defecto en Grafana.</p>
<p>Para la configuracion de la base de datos cargaremos este script al contenedor de docker a traves de &ldquo;Mysql-Client&rdquo;.</p>
<p><strong>comandos.sql</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-MySql" data-lang="MySql"><span style="display:flex;"><span><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">DATABASE</span> <span style="color:#66d9ef">IF</span> <span style="color:#66d9ef">EXISTS</span> thunder;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">DATABASE</span> thunder;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">USE</span> thunder;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#66d9ef">IF</span> <span style="color:#66d9ef">EXISTS</span> main_data;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#a6e22e">main_data</span> (
</span></span><span style="display:flex;"><span>  id <span style="color:#66d9ef">BIGINT</span> <span style="color:#66d9ef">AUTO_INCREMENT</span> <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">time</span> <span style="color:#66d9ef">BIGINT</span>,
</span></span><span style="display:flex;"><span>  lat <span style="color:#66d9ef">DOUBLE</span>,
</span></span><span style="display:flex;"><span>  lon <span style="color:#66d9ef">DOUBLE</span>,
</span></span><span style="display:flex;"><span>  alt <span style="color:#66d9ef">INT</span>,
</span></span><span style="display:flex;"><span>  pol <span style="color:#66d9ef">INT</span>,
</span></span><span style="display:flex;"><span>  mds <span style="color:#66d9ef">INT</span>,
</span></span><span style="display:flex;"><span>  mcg <span style="color:#66d9ef">INT</span>,
</span></span><span style="display:flex;"><span>  status <span style="color:#66d9ef">INT</span>,
</span></span><span style="display:flex;"><span>  region <span style="color:#66d9ef">INT</span>,
</span></span><span style="display:flex;"><span>  delay <span style="color:#66d9ef">FLOAT</span>,
</span></span><span style="display:flex;"><span>  lonc <span style="color:#66d9ef">INT</span>,
</span></span><span style="display:flex;"><span>  latc <span style="color:#66d9ef">INT</span>
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#66d9ef">IF</span> <span style="color:#66d9ef">EXISTS</span> signals;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#a6e22e">signals</span> (
</span></span><span style="display:flex;"><span>  id <span style="color:#66d9ef">BIGINT</span> <span style="color:#66d9ef">AUTO_INCREMENT</span> <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span>,
</span></span><span style="display:flex;"><span>  main_data_id <span style="color:#66d9ef">BIGINT</span>,
</span></span><span style="display:flex;"><span>  sta <span style="color:#66d9ef">INT</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">time</span> <span style="color:#66d9ef">BIGINT</span>,
</span></span><span style="display:flex;"><span>  lat <span style="color:#66d9ef">DOUBLE</span>,
</span></span><span style="display:flex;"><span>  lon <span style="color:#66d9ef">DOUBLE</span>,
</span></span><span style="display:flex;"><span>  alt <span style="color:#66d9ef">INT</span>,
</span></span><span style="display:flex;"><span>  status <span style="color:#66d9ef">INT</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">FOREIGN</span> <span style="color:#66d9ef">KEY</span> (main_data_id) <span style="color:#66d9ef">REFERENCES</span> <span style="color:#a6e22e">main_data</span>(id)
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>Lo cargaremos con:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Bash" data-lang="Bash"><span style="display:flex;"><span>mysql -h &lt;IP&gt; -u root -p -vvv &lt; comandos.sql
</span></span></code></pre></div><p>Donde <!-- raw HTML omitted --> sera la direccion IP del contenedor de Docker.</p>
<p>Una vez configurada la base de datos accederemos al panel de Grafana desde Data Sources -&gt; Add New Data Source -&gt; Mysql<br>
Completaremos los campos necesarios con las credenciales indicadas.</p>
<p><img alt="Grafana" src="/images/ThunderDB/Grafana.png"></p>
<p>Nota: En caso de no disponer de un certificado TLS/SSL marcaremos la casilla que deshabilita la conexion segura.</p>
<p>Una vez conectada la base de datos MySql con Grafana procederemos a crear la Dashboard que muestre los datos.</p>
<p>Nos dirigiremos al apartado &ldquo;Dashboards&rdquo; y crearemos una nueva desde el boton &ldquo;New Dashboard&rdquo; y &ldquo;Add Visualization&rdquo;.</p>
<p>Nos solicitará un <strong>Data Source</strong> e introduciremos el que acabamos de crear con MySql.</p>
<p>Tras desplegarse correctamente deberemos crear una consulta que sea capaz de recoger los datos recibidos y mostrarlos en la grafica.<br>
Ejemplos:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-MySql" data-lang="MySql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">FROM_UNIXTIME</span>(<span style="color:#66d9ef">time</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">1000000000</span>) <span style="color:#66d9ef">AS</span> <span style="color:#66d9ef">time</span>, <span style="color:#75715e">-- si tu tiempo está en nanosegundos, ajusta la conversión
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  lat,
</span></span><span style="display:flex;"><span>  lon,
</span></span><span style="display:flex;"><span>  alt
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span> main_data
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> <span style="color:#66d9ef">time</span> <span style="color:#66d9ef">DESC</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">1000</span>;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Mysql" data-lang="Mysql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">FROM_UNIXTIME</span>(s.<span style="color:#66d9ef">time</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">1000000000</span>) <span style="color:#66d9ef">AS</span> <span style="color:#66d9ef">time</span>,
</span></span><span style="display:flex;"><span>  s.sta,
</span></span><span style="display:flex;"><span>  s.lat,
</span></span><span style="display:flex;"><span>  s.lon,
</span></span><span style="display:flex;"><span>  s.alt,
</span></span><span style="display:flex;"><span>  s.status
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span> signals s
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">JOIN</span> main_data m <span style="color:#66d9ef">ON</span> s.main_data_id <span style="color:#f92672">=</span> m.id
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> s.<span style="color:#66d9ef">time</span> <span style="color:#66d9ef">DESC</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">1000</span>;
</span></span></code></pre></div><p>Lanzando las consultas podremos ver que empiezan a mostrarse los datos en el Panle de Visualización.</p>
<p><img alt="Grafica" src="/images/ThunderDB/grafica.png"></p>
<h3 id="enhorabuena">Enhorabuena!</h3>
<p>Hemos conseguido almacenar una gran cantidad de datos y una visualización rápida y efectiva de ellos.<br>
Si eres un apasionado de los <strong>Truenos y Rayos</strong> es tu momento!</p>
<h3 id="conclusión">Conclusión</h3>
<p>A traves de un websocket podemos recibir muchisima información, con su adecuado manejo seremos capaces de una infinidad de cosas.<br>
Docker nos permite utilizar un entorno super optimizado y orientado a tareas especificas con su sistema de contenedores. Gracias a esto podemos desplegar diferentes entornos sin necesidad de sobrecargar nuestro equipo principal.<br>
Grafana es una herramienta muy potente de visualización de datos que de manera organizada y personalizada nos presentará la informacion que seamos capaces de cargar en todos los entornos de los que dispone.</p>
<p>Hasta la vista Hackers.<br>
Kerneloop.</p>
]]></content></item><item><title>Microtik Router</title><link>https://kerneloop.github.io/posts/microtik-router/</link><pubDate>Sun, 22 Jun 2025 11:51:30 +0200</pubDate><guid>https://kerneloop.github.io/posts/microtik-router/</guid><description>Que es Mikrotik MikroTik es una marca fabricante de equipos de red. Desarrolla y vende enrutadores de red cableados e inalámbricos, conmutadores de red, puntos de acceso, así como sistemas operativos y software auxiliar.
Porque Mikrotik Es reconocido, tiene un software llamado RouterOS, el cual nos permitirá un manejo amplio en todas las configuraciones que podamos imaginar! Con Mikrotik Puedes hacer Cualquier cosa.
Primeros Pasos Dispondremos de un Router Mikrotik hAP Lite para este laboratorio.</description><content type="html"><![CDATA[<h2 id="que-es-mikrotik">Que es Mikrotik</h2>
<p>MikroTik es una marca fabricante de equipos de red. Desarrolla y vende enrutadores de red cableados e inalámbricos, conmutadores de red, puntos de acceso, así como sistemas operativos y software auxiliar.</p>
<h2 id="porque-mikrotik">Porque Mikrotik</h2>
<p>Es reconocido, tiene un software llamado RouterOS, el cual nos permitirá un manejo amplio en todas las configuraciones que podamos imaginar!
Con Mikrotik Puedes hacer <em><strong>Cualquier cosa</strong></em>.</p>
<h2 id="primeros-pasos">Primeros Pasos</h2>
<p>Dispondremos de un Router Mikrotik hAP Lite para este laboratorio. Es versatil, comodo y muy potente.
Precio actual -&gt; 20-30 Euros.</p>
<p>El primer paso es conectar a tu equipo <strong>Windows</strong> o <strong>Linux</strong> a traves de un cable RJ45 al primer puerto del router.
Una vez se encienda el Led Verde accederemos al router a traves del programa <a href="https://mikrotik.com/download" title="Winbox">WinBox</a>.
Cuando haya iniciado deberá de aparecer una interfaz como esta. Tambien verás la direccion MAC de tu Mikrotik.</p>
<p><img alt="Mikrotik-Main" src="/images/Mikrotik-Routing/Main-Winbox.png"></p>
<p>Por defecto, las credenciales son <strong>Username:</strong> admin <strong>Password:</strong> vacía</p>
<p>Haremos click en conectar y nos solicitará unas nuevas credenciales.<br>
Una vez introducidas nos redireccionará al menu principal desde el que podremos configurar absolutamente TODO!</p>
<h3 id="enhorabuena">Enhorabuena!</h3>
<p>Has accedido por primera vez a tu Router.<br>
A partir de aqui todo son maravillas, comienza tu exploración con el Networking.</p>
]]></content></item><item><title>Hello World</title><link>https://kerneloop.github.io/posts/hello-world/</link><pubDate>Sat, 21 Jun 2025 00:20:14 +0200</pubDate><guid>https://kerneloop.github.io/posts/hello-world/</guid><description>Hola Mundo. ¿Acaso no es asi como empieza todo?
Es impresionante como un hola puede romper esa barrera entre el no puedo y el primer paso. Esa barrera que se hace tan grande y fría como un muro. La reducimos con un poquito de nosotros cada día, un ratito libre con un café por las mañanas, en una escapada para merendar&amp;hellip;.. La rutina hace al monje.
Poco a poco ire publicando esos pequeños pasitos que iré dando en mis ratos libes, espero que disfrutes del proceso tanto como yo!</description><content type="html"><![CDATA[<h2 id="hola-mundo">Hola Mundo.</h2>
<p>¿Acaso no es asi como empieza todo?</p>
<p>Es impresionante como un hola puede romper esa barrera entre el no puedo y el primer paso.
Esa barrera que se hace tan grande y fría como un muro. La reducimos con un poquito de nosotros cada día,
un ratito libre con un café por las mañanas, en una escapada para merendar&hellip;.. La rutina hace al monje.</p>
<p>Poco a poco ire publicando esos pequeños pasitos que iré dando en mis ratos libes, espero que disfrutes del proceso tanto como yo!</p>
<p>Kerneloop.</p>
]]></content></item></channel></rss>